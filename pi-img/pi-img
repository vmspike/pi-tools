#!/bin/bash

readonly SCRIPT_VERSION='0.8'

# Bash version in numbers like 4003046, where 4 is major version, 003 is minor, 046 is subminor.
printf -v BV '%d%03d%03d' "${BASH_VERSINFO[0]}" "${BASH_VERSINFO[1]}" "${BASH_VERSINFO[2]}"
if ((BV < 4003014)); then
    echo "ERROR: bash version ${BASH_VERSION} is too old, minimal version is 4.3.14" >&2
    exit 1
fi

read -rd '' USAGE <<'EOFUSAGE'
DESCRIPTION
    Helps to manage disk images for single board computers: create, flash, mount, modify.

USAGE
    pi-img [--config CONFIG] [ACTION] [OPTIONS]

ACTION
    help, --help, usage, man
        Print this help. This is the default if run without arguments.
        The text outputs to stderr and exit code is 255.

        Action "man" behave a bit differently: try to print using pager
        ("less" or "more" in most cases) or stdout if no pager. Exit code in
        this case is equal to pager exit code.

    create
        Create custom disk image from a source image.

        It's recommended to create the image on the same hardware as the image
        destination hardware.

        See OPTIONS for more info.

    flash
        Flash existing disk image to SD card optionally with additional
        changes on just flashed SD card (like expanding rootfs partition to
        fill all available space, generate unique keys, etc.). Additional
        changes speed up first boot and may help to avoid first boot issues.

    mount
        Mount all partitions from the disk image to "--mount-dir" value.
        Required subfolders for each partition will be automatically created.
        All already mounted image partitions will be preliminary unmounted.

    umount, unmount
        Unmount all mounted disk image partitions.

    version, --version
        Output the script version to stdout and exit.

    check-deps, deps
        Check for existence of all binaries ever present in the script. Output
        the error mesage for each non-existing binary.
        Return code is 0 if all binaries exists, 1 if some binary does not
        exist.
        Recommended to run on first launch to be sure that all dependencies
        satisfied.
        Some binaries are optional but recommended, if does not exist
        alternatives will be used instead.

    solve-deps
        Experimental! Only for deb-based OS.
        Find and install required packages for the script.
        Current version just install predefined list of packages without
        attempt to find necessary list by comparison tool and package.
        Finally dependency check will be executed as in "check-deps" action.

OPTIONS
    Notes:
        Option and its value can be specified on commandline using syntax:
            --option VALUE
            OR
            --option=VALUE

        All values of boolean options [0|1] can be specified using various
        case insensitive words:
                True:  1, y, yes, true
                False: 0, n, off, false

            If short option is available (let's say -o) it can be specified as:
                True:  -o1, -o
                False: -o0
            Note: Empty values (if VALUE is an empty string '') will be kept empty,
                  but True/False check `((''))` for them is False (has return code 1).

        All required options for specific action with no defaults will be
        asked interactively if interactive mode enabled. Others will use
        default values.

        All relative directories will be converted to absolute (by "realpath" util).

        Some options are useless with some actions so takes no effect.

    --config, -c CONFIG
        Must be the first argument if specified, before ACTION!
        Options from config file overrides script defaults.

        To overwrite default options in config file you need to convert option
        name to upper case and replace "-" with "_", e.g.:
            --work-dir './work'
        will be
            WORK_DIR='./work'
        You also may want to see "Defaults" section in the script sources.
        You must follow bash syntax in config file, it will be sourced after
        script defaults initialization.

        Defaults to /etc/pi-img.conf

    --work-dir, -w WORK_DIR
        Work dir. The script will use it for some temporary or final files.
        It's also default for base dir for source disk image.

        Defaults to current directory ("PWD" shell variable).

    --tmp-dir TMP_DIR
        Directory for small temporary files. It can be kept unclean if an
        error occured. If this option is omitted default directory will be
        created automatically. If present the directory must exist already.

        Defaults to /tmp/pi-img.tmp.d

    --rootfs-changes-dir ROOTFS_CHANGES_DIR
        Recursively copy all content from this dir to rootfs of the image on
        image creation.
        All copied files will be owned by root and has the same permissions,
        so you may need to adjust ownership manually after creation (e.g. use
        creation hooks) or use --rootfs-changes-tarball instead.

        Has no default

    --rootfs-changes-tarball ROOTFS_CHANGES_TARBALL
        Extract tar archive to rootfs of the image. It's useful if you want to
        apply exactly the same ownership and permissions as in tar pack.

        To create compatible tarball you may use the command like this:
            tar cavf ../pi.rootfs-changes.txz ./
        Assuming that current dir ./ is a directory where required changes present.

        Has no default

    --root-part-num ROOT_PART_NUM
        Specify rootfs partition number. It required in some cases, so
        recommended to set it explicitly.
        Autodetection detects rootfs by the precense of /etc/fstab file.

        Defaults to '' (try to autodetect)

    --boot-part-num BOOT_PART_NUM
        Specify boot partition number (if any). It required in some cases, so
        recommended to set it explicitly.
        Autodetection detects boot partition by parsing /etc/fstab file on rootfs.

        Defaults to '' (try to autodetect)

    --source-image-url, -u SOURCE_IMAGE_URL
        URL for source disk image to download.
        Will be used if no local disk image usage requested.

        Defaults to latest Raspbian lite (no graphical UI, command line only):
            https://downloads.raspberrypi.org/raspbian_lite_latest

    --raspbian-name, -n RASPBIAN_NAME
        Base Raspbian image name.
        If the image with the same name exists in WORK_DIR it will be reused.
        Extension ".img" will be automatically added if absent.
        It will be also used as a first part of the final disk image name.

        Defaults to automatically extract from --source-image-url value if
        exists and available, or fallback to "raspbian.img".

    --pi-image-version, -v PI_IMAGE_VERSION
        Disk image version. Alphanumeric characters with dot and underscore only.
        Will be used in final disk image name.

        Has no default value.

    --pi-image-version-file PI_IMAGE_VERSION_FILE
        Full path of filename for PI_IMAGE_VERSION on disk image.
        Set to empty string '' if you don't want to save image version to the
        file on image creation.

        Defaults to /etc/disk_image_version

    --mount-dir MOUNT_DIR
        Base directory where loopback image or SD card partitions will be
        mounted to (subdirectories for each will be automatically created and
        finally removed).

        Defaults to TMP_DIR value.

    --default-pi-password DEFAULT_PI_PASSWORD
        Will be used for user (uid 1000) initial password on image creation.

        Has no default value.

    --keep-src-image [0|1]
    -k1, -k
    -k0
        Decide if source/original disk image will be kept untouched or new
        disk image will overwrite it. Not to keep is faster and disk space
        effective (no cloning) but not suitable for multiple [re]builds
        because it will have to be redownloaded in this case.

        Defaults to 1 (keep).

    --img, --image IMG
        Path to disk image to flash to SD card.
        It can be also specified as an argument exactly after "flash" action
        (avoiding --img option name).

        Has no default value.

    --sdcard SDCARD
        Path to SD card device where to flash the image.
        Must be the block device (like "/dev/mmcblk0") or the character special
        device (like "/dev/null").
        It can be also specified as a 3rd argument exactly after IMG this way:
        pi-img flash path/to/IMAGE.img /dev/SDCARD0

        Has no default value.

    --sdcard-erase-on-flash [0|1]
    -e1, -e
    -e0
        If SD card needs to be erased before flashing. It may take few minutes
        depends on SD card speed.
        Can be specified for security reasons to remove previous SD card content.

        Warning: Because of the nature of SD card some cells could be not really
        erased but only marked as empty, so it's not clear if such erasing is
        secure enough.

        Defaults to 0 (do not erase).

    --sdcard-erase-on-flash-src SDCARD_ERASE_ON_FLASH_SRC
        Source device to use for erasing.
        /dev/zero and /dev/urandom are reasonable choices.

        Defaults to /dev/zero

    --sdcard-verify-integrity [0|1]
        After flashing verify that the image written to SD card matches
        original image. It verifies only leading part of SD card of the same
        size as the image, so it does not protect against "fake SD card size"
        issue if the image size is relatively small.

        Defaults to 1 (verify)

    --sdcard-check-rootfs-for-errors [0|1]
        After flashing check rootfs filesystem for errors.

        Defaults to 0 (do not check)

    --sdcard-verify-real-size [0|1]
        Not implemented!
            You may use f3probe instead (from f3 package), e.g. on unmounted SD run:
                sudo f3probe --destructive --time-ops /dev/SDCARD
            For more info visit https://fight-flash-fraud.readthedocs.io

        Verify that SD card size reported by controller matches real size.
        You may want to run it once for new/unknown SD cards to be sure that
        SD card is not a fake, e.g. detected as 64GB but real size is 8GB, all
        data higher will be lost.

        Defaults to 0 (do not verify)

    --dd-bs DD_BS
        dd "bs" (block size) option. See "man dd" for more info.
        It's not recommended to set this value to less than 512.

        For USB 3.0/3.1 cardreader and UHS SD card increasing of this value
        can significantly speedup flashing. Measure optimal value for your
        cardreader and SD card.

        Defaults to 8M

    --dd-conv DD_CONV
        dd "conv" comma separated options list for flashing (not for erasing).
        See "man dd" for more info.
        "sparse" value can decrease flashing time for 20-40% for sparse
        images by trying to seek rather than write the output for NUL input
        blocks, but can lead to errors on not zeroed SD card.
        Empty line '' allowed to discard defaults.
        "fsync" conv option will be automatically prepended and can be
        overwritten only by "fdatasync" option.

        Defaults to '' (empty string).

    --dd-oflag DD_OFLAG
        dd "oflag" comma separated options list for flashing and erasing.
        Allowed options are only "direct", "nonblock" and '' (empty string).

        Defaults to "direct".

    --dd-status DD_STATUS
        dd "status" option. See "man dd" for more info.
        "progress" value shows periodic transfer statistics (if supported).

        Defaults to "progress" for interactive mode, "none" for non-
        interactive, empty for dd versions below 8.24.

    --early-boot-ssh [0|1]
        Force enabling/disabling SSH server before successful boot by creation
        of /boot/ssh file.
        It's Raspbian specific, other OSes may ignore this file.

        Defaults to '' (keep existing configuration)

    --shrink-rootfs [0|1]
        Shrink image rootfs partition on image creation to decrease virtual image size.
        It can speedup flashing when "--dd-conv sparse" applied, but it's
        suitable only for limited use cases when SD card already zeroed.

        If you're going to add some files to the image after creation you
        probably want to disable shrinking, otherwise it can be lack of free
        space.

        Defaults to 0 (do not shrink).

    --apt-extra-pkgs APT_EXTRA_PKGS
        Deb packages space and/or newline separated list which will be
        installed on image creation.

        Be sure you've quoted or escaped the argument APT_EXTRA_PKGS so it
        will be passed to the script as a single value.

        Defaults to '' (no packages will be installed).

    --apt-dist-upgrade [0|1]
    --apt-upgrade [0|1]
    --apt-autoremove [0|1]
        If "apt-get dist-upgrade", "apt-get upgrade", or "apt-get autoremove"
        correspondingly have to be run on disk image rootfs during image
        creation.
        If --apt-dist-upgrade enabled, "apt-get upgrade" will not be
        called regardless of --apt-upgrade state.

        Defaults to 0

    --pi-username PI_USERNAME
        The new name for the user with UID 1000. In Raspbian it's "pi" by
        default, so "pi" user will be renamed. Its home dir and all related
        files also will be changed correspondingly.
        Set it to empty string '' if you want to keep it unchanged.

        Defaults to '' (keep existing username)

    --flash [0|1]
        To skip SD card flashing set this options to false.
        Can be useful if you want to apply post flashing actions to already flashed SD card.

        Defaults to 1 (proceed with flashing)

    --post-flashing [0|1]
        Post flashing actions can be enabled by setting this option to false.

        Post flashing actions useful to make actions directly with SD card
        (e.g. expand rootfs) as well as to make each SD card unique when you
        are going to flash the same image to multiple SD cards (e.g. use
        different SSH server keys or SSL certs).

        Defaults to 0 (do not run post flashing actions)

    --expand-rootfs [0|1]
        Expand rootfs after flashing to fill all available space of SD card.
        It may help to speedup first boot and/or in situations when rootfs
        expanding on first boot is disabled or not implemented in the image.

        Works only if "--post-flashing 1".

        Defaults to 0 (do not expand, the OS may do so on first boot of pi).

    --regenerate-ssh-server-keys [0|1]
        Regenerate SSH server keys after flashing.

        Works only if "--post-flashing 1".

        Defaults to 1 (regenerate).

    --tar-pack [0|1]
        If final image have to be packed to tar archive after creation.

        Defaults to 0 (do not pack)

    --cert-generate [0|1]
        Generates self-signed SSL certs after flashing.
        If enabled it generates two pairs of SSL certs inside PI_SSL_DIR:
            main.key
            main.crt
            any.key
            any.crt
        as well as DH key:
            dh.pem
        See also corresponding --cert-* options.

        Works only if "--post-flashing 1".

        Defaults to 0 (do not generate).

    --cert-subj CERT_SUBJ
        Self-signed certificates subject string for "--cert-generate" option.

        Defaults to:
            /C=00/ST=self/L=self/O=self/OU=self/CN=*/emailAddress=self@example.com/UID=${RANDOM}

        where ${RANDOM} is a random number between 0 and 32767. UID randomness
        required for some web browsers which might slow down TLS handshake
        when multiple certs saved with the same subject.

    --cert-dh-sz CERT_DH_SZ
        Diffie-Hellman certificate size.
        Used in post flashing part to generate unique dh.pem file.
        Allowed values: 256, 512, 1024, 2048, 4096, 8192, 16384

        Works only if "--cert-generate 1".

        Defaults to 1024 (provide enough security with reasonable generation time)

    --cert-valid-days CERT_VALID_DAYS
        Certificates will be valid for CERT_VALID_DAYS days.

        Works only if "--cert-generate 1".

        Defaults to 18262 (~50 years)

    --interactive [0|1]
    -i1, -i
    -i0
        In interactive mode user will be asked for an action (input option
        variable, input password, etc.)
        In non-interactive mode the script will exit if situation cannot be
        solved without user intervention.

        If the shell itself is not interactive the script fallback to non-
        interactive mode regardless of specified value or defaults.

        Defaults to 1 (interactive).

    --sd-overclock [0|25|40|50|80|100]
        Overclock/downclock microSD reader: set SD reader frequency in MHz.
        It's "Raspberry Pi 3 Model B" specific. RPi3B default is 50 MHz.

        For development purposes if you use high end UHS SD card and existing
        /boot/config.txt allows to overclock SD card (has commented line with
        "dtparam=sd_overclock=") you can specify overclock frequency on
        flashing.

        It allows to increase SD card speed up to ~42MB/s (on 100MHz) while
        non-overclocked limit is ~22MB/s (50MHz). It's because RPi do not support UHS
        mode at all but well designed SD cards can increase speed in SD mode:
        https://www.reddit.com/r/raspberry_pi/comments/4aoc3r/how_to_overclock_the_microsd_card_reader_on_a/

        Defaults to 0 (keep existing configuration)

    --automounting-enabled [0|1]
        Notify the script if automounting tool works in user UI.

        If this option explicitly specified automounting tool detection will
        be skipped, which may speedup execution for few seconds.

        Defaults to '' (autodetect)

    --dry-run [0|1]
        Not implemented

EXAMPLES
    - What's going on?
    pi-img man         # To see this help
    pi-img check-deps  # To check if your system has all dependencies satisfied
    pi-img solve-deps  # Solve them if not (experimental, for Debian derivatives only)


    - Have an image, how to [securely] flash it?
    # Fast flash with default options
    pi-img flash ./path/to/pi.img /dev/mmcblk0

    # Slow but secure(?) flash, all previously existing data erased and filled by
    # pseudo random data before flashing, then flashed as is (do not skip NUL
    # input blocks).
    pi-img flash --img ./pi.img --sdcard /dev/mmcblk0 \
        --sdcard-erase-on-flash yes --sdcard-erase-on-flash-src /dev/urandom


    - Have nothing, but want to flash custom disk image...
    # Note: It can be required to build the image on Pi itself (or compatible
    # host) to enable some image options.

    # Create temporary work dir if want to be sure you're safe and cd to it
    cd $(mktemp -dp ./)

    # Download this script
    # Note: "wget" works only for public repos, for private use web browser
    wget https://github.com/vmspike/pi-tools/raw/master/pi-img/pi-img
    ln -vs "$(realpath ./pi-img)" /usr/local/bin/
    # OR clone full repo
    git clone git@github.com:vmspike/pi-tools.git || git clone https://github.com/vmspike/pi-tools.git
    ln -vs "$(realpath ./pi-tools/pi-img/pi-img)" /usr/local/bin/

    # Build fresh development image with required custom options,
    # input your user password for sudo when asked
    pi-img create --pi-version dev \
        --keep-src-image no \
        --tar-pack no \
        --early-boot-ssh yes \
        --default-pi-password 'Sup&Dup!!!1' \
        --apt-dist-upgrade 1 \
        --apt-extra-pkgs 'htop vim whatever'

    # If you've built the image on the device and have no USB cardreader move just
    # created image to your host and flash there than.
    # Note: "scp" doesn't support sparse files so use "rsync":
    #     rsync -aPS pi@PiIP:/path/to/image/*.pi-dev.img ./
    # Or just detach SD card form Pi and attach to your PC, mount, and use the image
    # on its filesystem for flashing.

    # Flash it
    pi-img flash THEIMAGE.img /dev/mmcblk0
    # If you're going to flash multiple SD cards sequentially and have enough
    # free RAM to increase flashing speed you can preliminary add the
    # image to filesystem cache:
    cat THEIMAGE.img >/dev/null
    # or copy it to RAM disk "/dev/shm/" and flash from it.
    # It may speedup flashing for few % depends on your disk subsystem.
    # Also you can use optimal block size for flashing (may be 8M or higher
    # against default 4M), it also can drop couple of seconds:
    pi-img flash --img THEIMAGE.img --sdcard /dev/mmcblk0 --dd-bs 16M


    - Want to apply some changes to existing image without recreation.
    # If you do not need to run binaries in chroot you can apply them on the host with any CPU arch:
    # Mount existing image
    pi-img mount THEIMAGE.img
    # Apply changes and unmount
    pi-img umount THEIMAGE.img
    # You can unmount using 'sudo umount /path/to/boot /path/to/rootfs' as well
EOFUSAGE


### Defaults
export LC_ALL=C  # To avoid locale issues
TIMESTAMP_FORMAT='%Y-%m-%dT%H:%M:%S'
WGET_TIMEOUTS='--dns-timeout=10 --connect-timeout=20 --read-timeout=30'
DEPENDENCIES='blkdiscard blockdev bsdtar chmod chown cmp cp dd e2fsck fallocate grep ln losetup ls mkdir mkpasswd mktemp mount mv openssl parted realpath resize2fs rmdir sed sfdisk sort stat sudo sync tail tee touch tr truncate tune2fs umount uname usermod wget zgrep'  # The script dependencies
DEPENDENCIES_OPTIONAL='f3probe less zerofree'  # The script optional dependencies, other tools will be used instead if does not exist.

# Default compression level for xz compressor (used in image pack creation).
# -9 use 65M for unpack, -8 use 33M, -7 use 17M (for others see "man xz"),
# so -7 is optimal for pack_sz+unpack_mem when pack size is about 250M, so optimal
# for flashing by pi-reset because it use ramdisk. For larger pack size
# higher compression level can be considered.
XZ_LEVEL=7

TMP_DIR_DEFAULT_BASENAME='pi-img.tmp.d'  # Added to default TMP_DIR value (if --tmp-dir option is not specified)
TMP_DIR_DEFAULT_DIRNAME='/tmp'

# UIG/GID is fixed, do not change
PI_UID=1000
PI_GID=1000

HOST_CPU_ARCH=$(exec -c uname -m)  # CPU arch of the host where the script executed
# TARGET_CPU_ARCH='armv7l'  # CPU arch of the pi where created disk image will be used
# TARGET_ABI='armhf'

# shellcheck disable=2164
[[ -d "${PWD}" ]] || cd ./  # Workaround if work dir was renamed after cd to it
WORK_DIR=${PWD}  # PWD is the current working directory as set by the cd command
SOURCE_IMAGE_URL='https://downloads.raspberrypi.org/raspbian_lite_latest'
SOURCE_IMAGE_URL_FILENAME=''  # Temporary empty initial variable for SOURCE_IMAGE_URL
RASPBIAN_NAME=''  # By default will be get from commandline args, SOURCE_IMAGE_URL, or fallback to raspbian.img
PI_IMAGE_VERSION=''  # User will be prompted if empty
DEFAULT_PI_PASSWORD=''  # Will be used for user (with id 1000) initial password
KEEP_SRC_IMAGE=1  # Keep base Raspbian image unmodified. If false disk image will overwrite it (faster).
SDCARD=''  # The device name of SD cardreader, empty to ask interactively, can be like /dev/mmcblk0
SDCARD_ERASE_ON_FLASH=0  # If SD card need to be erased before flashing (mostly for security reasons)
SDCARD_ERASE_ON_FLASH_SRC='/dev/zero'  # Source device to use for erasing, /dev/zero and /dev/urandom are reasonable choices

SDCARD_VERIFY_INTEGRITY=1
SDCARD_VERIFY_REAL_SIZE=0
SDCARD_CHECK_ROOTFS_FOR_ERRORS=0

DD_BS=8M  # Default dd block size (only for some dd commands), 1M is 1048576
DD_CONV=''  # Default dd conv option (only for flash dd command)
DD_STATUS=''  # Choice depends on INTERACTIVE value and dd version
DD_CONV_FSYNC='fsync'  # Can be fsync or fdatasync or empty
DD_OFLAG='direct'  # Can be direct and/or nonblock (comma separated)

IMG=''  # Disk image for flashing. User will be prompted if empty.
EARLY_BOOT_SSH=''  # Force enabling/disabling SSH server before successful first boot
TAR_PACK=0  # If final image have to be packed to tar archive after creation
INTERACTIVE=1
AUTOMOUNTING_ENABLED=''
ROOTFS_CHANGES_DIR=''
ROOTFS_CHANGES_TARBALL=''
# DRY_RUN=0
PI_SSL_DIR='/etc/ssl'  # No trailing slash
CERT_SUBJ="/C=00/ST=self/L=self/O=self/OU=self/CN=*/emailAddress=self@example.com/UID=${RANDOM}"
# 1024 DH because 2048 generation takes ~35min on RPi, while 1024 takes few
# minutes (so can be done in background) with enough security for current
# needs
CERT_DH_SZ=1024
CERT_VALID_DAYS=18262

APT_EXTRA_PKGS=''

APT_DIST_UPGRADE=0
APT_UPGRADE=0
APT_AUTOREMOVE=0
PI_IMAGE_VERSION_FILE='/etc/disk_image_version'

# The new name of the user with uid 1000. In Raspbian it's "pi" by default, so "pi" user will be renamed
PI_USERNAME=''

FLASH=1
LOG_SCRIPT_VERSION=1  # Show the script version on each run
SHRINK_ROOTFS=0  # Shrink rootfs on image creation to speedup flashing

# Empty values to autodetect
ROOT_PART_NUM=''
BOOT_PART_NUM=''

SD_OVERCLOCK=0

# Post flashing options
POST_FLASHING=0
CERT_GENERATE=0  # Create self-signed SSL certs
EXPAND_ROOTFS=0  # Expand rootfs to fill all SD card space on postflashing
REGENERATE_SSH_SERVER_KEYS=1  # Regenerate ssh keys on postflashing

shopt -s dotglob

# Read CONFIG from commandline args if specified as a first argument
CONFIG='/etc/pi-img.conf'
if [[ "$1" == '--config' || "$1" == '-c' ]]; then
    CONFIG="$2"
    shift 2
    [[ -r "${CONFIG}" ]] || { echo "No such file or not readable: ${CONFIG}"; exit 1; }
fi
### END Defaults


# Export options from config if present
# shellcheck disable=1090
[[ -r "${CONFIG}" ]] && . "${CONFIG}"

### Functions
log() {
    # if [[ -z ${TIMESTAMP_FORMAT} ]]; then
    #     local TIMESTAMP_FORMAT
    #     TIMESTAMP_FORMAT='%Y-%m-%dT%H:%M:%S'
    # fi

    if ((INTERACTIVE)); then
        # Colorize output
        if [[ -z "${*%%ERROR:*}" ]]; then
            printf "%(${TIMESTAMP_FORMAT})T %5d %s\n" '-1' $$ $'\e[1;31m'ERROR$'\e[0m':$'\e[0;31m'"${*#ERROR:}"$'\e[0m'
        elif [[ -z "${*%%WARNING:*}" ]]; then
            printf "%(${TIMESTAMP_FORMAT})T %5d %s\n" '-1' $$ $'\e[1;33m'WARNING$'\e[0m':$'\e[0;33m'"${*#WARNING:}"$'\e[0m'
        elif [[ -z "${*%%OK:*}" ]]; then
            printf "%(${TIMESTAMP_FORMAT})T %5d %s\n" '-1' $$ $'\e[1;32m'OK$'\e[0m':$'\e[0;32m'"${*#OK:}"$'\e[0m'
        elif [[ -z "${*%%INFO:*}" ]]; then
            printf "%(${TIMESTAMP_FORMAT})T %5d %s\n" '-1' $$ $'\e[1;36m'INFO$'\e[0m':$'\e[0;36m'"${*#INFO:}"$'\e[0m'
        else
            printf "%(${TIMESTAMP_FORMAT})T %5d %s\n" '-1' $$ $'\e[0;36m'"$*"$'\e[0m'
        fi
    else
        # Use plain text
        printf "%(${TIMESTAMP_FORMAT})T %5d %s\n" '-1' $$ "$*"
    fi
}


quit() {
    if [[ -n $2 ]]; then  # Message specified
        if (($1)); then  # Non-zero exit code
            log "ERROR: $*" >&2
        else
            log "OK: $*" >&2
        fi
    fi

    # TODO: check if dir is empty to avoid useless log output, --ignore-fail-on-non-empty is not usable because suppress all error messagess.
    [[ "${TMP_DIR##*/}" == "${TMP_DIR_DEFAULT_BASENAME}" && -d "${TMP_DIR}" ]] && sudo rmdir -v -- "${TMP_DIR}"

    sync
    case "${ACTION}" in
        create|flash)
            s=${SECONDS}
            # shellcheck disable=2017
            log "Script execution time: ${s}s ($((s/3600))h $(((s-s/3600*3600)/60))m $((s%60))s)"
            ;;
    esac
    exit "$1"
}


##
# Ask for sudo password first time to avoid asking later
##
ask_for_sudo_password() {
    ((UID==0)) && return 0  # Already run as root
    local n=2  # Trying n times
    for ((i=0;i<n;i++)); do
        if sudo -n true 2>/dev/null; then
            # Password already remembered
            break
        else
            # Password not yet remembered
            if ((INTERACTIVE)); then
                log 'Superuser privileges required for some actions, please input your user password for sudo access:'
                sudo true && break  # Ask for password interactively
                log "Failed to get superuser rights (attempt $((i+1))/2)"
            else
                quit 240 'Unable to ask for sudo access in non-interactive mode'
            fi
        fi
    done
    ((i<n)) || quit 5 'Failed to get superuser rights'
}


##
# Unmount existing device partitions if any.
# Specify the device name as a first argument.
##
unmount_mounted_partitions() {
    local rval SDCARD proc_mounts tmp dev
    rval=0  # Success by default
    SDCARD=$1
    if [[ -z "${SDCARD}" ]]; then
        quit 1 'unmount_mounted_partitions: invalid syntax: non empty argument required'
    fi

    # Have to preliminary make mountpoints snapshot
    read -rd '' proc_mounts </proc/mounts

    # shellcheck disable=2034,2162
    while read dev tmp; do
        # if [[ "${dev}" =~ ^"${SDCARD}"p?[0-9]+$ ]]; then
        if [[ "${dev::${#SDCARD}}" == "${SDCARD}" ]]; then
            # Mounted partition found
            log "Unmounting mounted partition: ${dev}"
            sudo umount -vA "${dev}" || rval=$?
            # log "Unmounting all partitions of the device: ${SDCARD}"
            # sudo umount -vA "${SDCARD}"* || rval=$?
            # break
        fi
    done <<<"${proc_mounts}"

    return "${rval}"
}


##
# Reread device partition tables.
# All device's partitions will be unmounted if automounting tool is enabled.
#
# Specify the device name as a first argument.
#
# Globals:
#   AUTOMOUNTING_ENABLED
##
reread_partitions() {
    local SDCARD
    SDCARD=$1
    if [[ -z "${SDCARD}" ]]; then
        quit 1 'reread_partitions: invalid syntax: non empty argument required'
    fi

    if [[ -z "${AUTOMOUNTING_ENABLED}" ]]; then
        # Check if automounting tool enabled for this SD card
        log 'Trying to detect automounting tool...'
        sleep 2  # Give time for automounting tool (if any) to mount partitions
        log "Reread ${SDCARD} partitions"
        # "blockdev --rereadpt" return non-zero exit code if the device is busy (e.g. mounted)
        if ! sudo blockdev --rereadpt "${SDCARD}"; then  # Failed to reread
            log 'Failed to reread device partitions, seems interfere with automounting tool.'
            log "INFO: Consider to disable automounting to avoid issues and speedup flashing."
            AUTOMOUNTING_ENABLED=1
        else  # Successful reread immediatelly after flashing
            # Check if will be automounted after successfull reread
            sleep 2  # Give time for automounting tool (if any) to mount partitions
            if ! sudo blockdev --rereadpt "${SDCARD}"; then  # Failed to reread after flashing
                log 'Failed to reread device partitions, seems interfere with automounting tool.'
                log "INFO: Consider to disable automounting to avoid issues and speedup flashing."
                AUTOMOUNTING_ENABLED=1
            else  # Successful reread
                log "Successful reread of ${SDCARD} partitions"
                log "Looks like automounting is disabled for ${SDCARD}, fine."
                AUTOMOUNTING_ENABLED=0
            fi
        fi
    fi

    if ((AUTOMOUNTING_ENABLED)); then
        sleep 2  # Give time for automounting tool to mount partitions
        unmount_mounted_partitions "${SDCARD}" || quit 22 'Failed to unmount device partitions before partitions reread attempt'
    fi

    log "Reread ${SDCARD} partitions"
    sudo blockdev --rereadpt "${SDCARD}"  # Return non-zero exit code if the device is busy (e.g. mounted)
    # shellcheck disable=2181
    if (($?)); then  # Failed to reread
        log 'Failed to reread device partitions using "blockdev --rereadpt", using "partprobe".'
        # Should work even with mounted partitions and return zero exit code
        sudo partprobe "${SDCARD}" || quit 22 'Failed to reread device partitions using "partprobe"'
    fi

    if ((AUTOMOUNTING_ENABLED)); then
        sleep 2  # Give time for automounting tool to mount partitions after reread
        unmount_mounted_partitions "${SDCARD}" || quit 22 'Failed to unmount device partitions after successful partitions reread'
    fi
}


##
# Generates random string with desired length from specified source.
# Usage: bpwgen [-v VAR] LEN SRC
# Default LEN is 8
# Default SRC is alphanumeric latin letters
# If SRC starts with - and such option exists it has special meaning
##
bpwgen() {
    local var src sl len i res
    if [[ $1 == '-v' ]]; then var=$2; shift 2; fi
    [[ -n "$1" ]] && len=$1 || len=8  # No check
    # [[ "$1" =~ ^[0-9]+$ ]] && len=$1 || len=8  # Regex check
    # (($1)) && len=$1 || len=8  # ARITHMETIC EVALUATION check
    case "$2" in
        ''|-an|--alphanumeric)  # Default
            src='0123456789abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ';;
        -a|--alpha)
            src='abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ';;
        -n|--numeric)
            src='0123456789';;
        -b|--no-ambiguous)
            src='2345679abcdefghjkmnpqrstuvwxyzACEFGHJKLMNPRSTUVWXYZ';;
        -l|--lowercase)
            src='0123456789abcdefghijklmnopqrstuvwxyz';;
        -u|--uppercase)
            src='0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZ';;
        -s|--secure)
            src='!"#$%&()*+,-./0123456789:;<=>?@ABCDEFGHIJKLMNOPQRSTUVWXYZ[\]^_`abcdefghijklmnopqrstuvwxyz{|}~'\';;
        *)  # Custom
            src=$2;;
    esac
    sl=${#src}
    for ((i=0;i<len;i++)); do
        res+=${src:$((RANDOM%sl)):1}
    done

    if [[ -n ${var} ]]; then
        declare -g "${var}"
        printf -v "${var}" '%s' "${res}"
    else
        printf '%s\n' "${res}"
    fi
}


##
# Gather image info.
#
# Set globals in conjunction with sfdisk output:
#   IMG_BS           - block size (always 512)
#   IMG_PART         - array with partitions basenames
#   IMG_PART_START   - array with partitions start blocks
#   IMG_PART_END     - array with partitions end blocks
#   IMG_PART_SECTORS - array with partitions sectors count
#   IMG_PART_SIZE    - array with partitions human readable sizes
#   IMG_PART_TYPE    - array with partitions types (e.g.: "W95 FAT32 (LBA)", "Linux")
# Also tries to autodetect ROOT_PART_NUM and BOOT_PART_NUM
##
gather_image_info() {
    local IMG p s e sc sz tp
    IMG=$1
    log 'Gather image info'
    sync
    # To be sure not to reuse existing values
    # unset IMG_BS
    IMG_BS=512  # Always 512 bytes because of *nix agreement
    IMG_PART=()
    IMG_PART_START=()
    IMG_PART_END=()
    IMG_PART_SECTORS=()
    IMG_PART_SIZE=()
    IMG_PART_TYPE=()

    # TODO: handle not sequential partition numbers here and in other places
    {
        read  # Ignore first line with headers
        while read -r p s e sc sz tp; do
            IMG_PART+=("${p##*/}")  # basename only, not full path
            IMG_PART_START+=("${s}")
            IMG_PART_END+=("${e}")
            IMG_PART_SECTORS+=("${sc}")
            IMG_PART_SIZE+=("${sz}")
            IMG_PART_TYPE+=("${tp}")
        done
    } <<<"$(LC_ALL=C exec sudo sfdisk --color=never -q -l -o device,start,end,sectors,size,type -- "${IMG}")"

    # TODO: implement deeper verification
    if  [[ -z "${IMG_BS}" \
        || -z "${IMG_PART[*]}" \
        || -z "${IMG_PART_START[*]}" \
        || -z "${IMG_PART_END[*]}" \
        || -z "${IMG_PART_SECTORS[*]}" \
        || -z "${IMG_PART_SIZE[*]}" \
        || -z "${IMG_PART_TYPE[*]}" \
        ]]; then
        quit 1 'Failed to gather image info'
    fi

    # Trying to autodetect ROOT_PART_NUM
    if [[ -z "${ROOT_PART_NUM}" ]]; then
        if ((${#IMG_PART[@]} == 1)); then
            log 'Single partition image, treat as rootfs.'
            ROOT_PART_NUM=1
        elif ((${#IMG_PART[@]} == 2)); then
            if  [[ "${IMG_PART_TYPE[0]}" =~ ^.*FAT.*$ \
                && "${IMG_PART_TYPE[1]}" == 'Linux' \
                ]]; then
                # FAT and Linux partitions
                log 'Double partitions image fat+linux, treat as boot+rootfs.'
                [[ -z "${BOOT_PART_NUM}" ]] && BOOT_PART_NUM=0
                ROOT_PART_NUM=1
            fi
        fi
    fi
}


##
# Mount all partitions from the image
#
# Also set globals:
#   IMG_MOUNTPOINTS[@]
#   IMG_ROOT_MOUNTPOINT
#   IMG_BOOT_MOUNTPOINT
##
mount_img() {
    local IMG i entry mp _
    IMG=$1
    if [[ -z "${IMG}" ]]; then
        log 'ERROR: Cannot mount: No image specified'
        return 1
    fi

    gather_image_info "${IMG}"

    ask_for_sudo_password

    IMG_MOUNTPOINTS=("${IMG_PART[@]/#/${MOUNT_DIR}/}")  # All image mountpoints, full paths.

    # Try to unmount if already mounted
    umount_img "${IMG}"

    log 'Creating path(s) for mounting (if required)'
            mkdir -vp "${IMG_MOUNTPOINTS[@]}" 2>/dev/null \
    || sudo mkdir -vp "${IMG_MOUNTPOINTS[@]}" \
    || quit 1 'Failed to create path(s) for mounting'

    log 'Mounting all partitions from the disk image:'
    for ((i=0;i<${#IMG_PART[@]};++i)); do
        case "${IMG_PART_TYPE[$i]}" in
            'BIOS boot'|MBR)
                log "Ignoring partition $((i+1)) of type ${IMG_PART_TYPE[$i]}"
                continue
                ;;
        esac
        sudo mount -v -o loop,rw,offset=$((IMG_PART_START[i]*IMG_BS)),sizelimit=$((IMG_PART_SECTORS[i]*IMG_BS)) "${IMG}" "${IMG_MOUNTPOINTS[$i]}" \
        || quit 6 "Failed to mount partition $((i+1))"
        # sudo mount -v -o loop,ro,offset=$((IMG_PART_START[i]*IMG_BS)),sizelimit=$((IMG_PART_SECTORS[i]*IMG_BS)) "${IMG}" "${IMG_MOUNTPOINTS[$i]}" \
        # || log "WARNING: Failed to mount partition $((i+1))"
    done

    # Trying to autodetect ROOT_PART_NUM and corresponding BOOT_PART_NUM by the presence of /etc/fstab
    # TODO: find proper way to detect root and boot partitions
    if [[ -z "${ROOT_PART_NUM}" ]]; then
        for ((i=0;i<${#IMG_MOUNTPOINTS[@]};++i)); do
            if [[ -f "${IMG_MOUNTPOINTS[$i]}/etc/fstab" ]]; then
                ROOT_PART_NUM=$((++i))
                if [[ -z "${BOOT_PART_NUM}" ]]; then
                    while read -r entry mp _; do
                        if [[ "${mp}" == '/boot' && "${entry%%=*}" == 'PARTUUID' ]]; then
                            BOOT_PART_NUM=${entry##*-}  # Only the part after -
                            BOOT_PART_NUM=${BOOT_PART_NUM#0}  # Remove leading 0 if any
                            # Expect sequential partition numbers only
                            if ! [[ "${BOOT_PART_NUM}" =~ ^[1-9][0-9]*$ ]] && ((BOOT_PART_NUM <= ${#IMG_MOUNTPOINTS[@]})); then
                                BOOT_PART_NUM=''
                            fi
                        fi
                    done <"${IMG_MOUNTPOINTS[$i]}/etc/fstab"
                fi
                break
            fi
        done
        if [[ -z "${ROOT_PART_NUM}" ]]; then
            log "WARNING: Failed to detect rootfs partition number, set it by --root-part-num option."
        fi
    fi


    # Set useful aliases for rootfs and boot IMG_MOUNTPOINTS if any
    if ((ROOT_PART_NUM)); then
        IMG_ROOT_MOUNTPOINT=${IMG_MOUNTPOINTS[$((ROOT_PART_NUM-1))]}
    else
        IMG_ROOT_MOUNTPOINT=''
    fi
    if ((BOOT_PART_NUM && BOOT_PART_NUM != ROOT_PART_NUM)); then
        IMG_BOOT_MOUNTPOINT=${IMG_MOUNTPOINTS[$((BOOT_PART_NUM-1))]}
    else
        IMG_BOOT_MOUNTPOINT=''
    fi

    # Be sure that rootfs is the last in this array to avoid unmounting issues
    if [[ -n "${IMG_ROOT_MOUNTPOINT}" && "${IMG_MOUNTPOINTS[-1]}" != "${IMG_ROOT_MOUNTPOINT}" ]]; then
        # TODO: implement
        :
    fi

    if [[ -n "${IMG_BOOT_MOUNTPOINT}" && -n "${IMG_ROOT_MOUNTPOINT}" && -d "${IMG_ROOT_MOUNTPOINT}/boot" ]]; then
        log 'Mount (bind) boot partition to /boot dir of rootfs'
        sudo mount --bind "${IMG_BOOT_MOUNTPOINT}" "${IMG_ROOT_MOUNTPOINT}/boot" || log 'ERROR: Failed to mount boot partition to /boot dir of rootfs'
    fi

    return 0
}


##
# Unmount all partitions from the image.
# If first argument exist unmount all mounted image partitions.
# If not unmount partitions from IMG_MOUNTPOINTS array (which have to be
# preliminary set by mount_img) and remove empty mountpoints.
##
umount_img() {
    if [[ -n "$1" ]]; then  # Unmount all image partitions
        local IMG tmploop l m n tmpmp tmp
        IMG=$1

        # sudo umount "${IMG_MOUNTPOINTS[@]}" &>/dev/null
        # tmploop=(); while read l; do tmploop+=("${l%%: *}"); done < <(exec -c losetup -j "${IMG}")
        tmploop=()
        # shellcheck disable=2162
        while read l; do
            tmploop+=("${l%%: *}")
        done <<<"$(losetup -j "${IMG}" | sort)"  # "sort" required to unmount rootfs partition last
        if [[ -n "${tmploop[*]}" ]]; then
            if [[ "$2" == '--rmdir' ]]; then
                # TODO: Fix the case when it's more than 10 loop devices
                tmpmp=()
                # shellcheck disable=2034,2068,2162
                while read l m n; do
                    tmpmp+=("${m}")
                done <<<"$(exec -c grep ${tmploop[@]/#/-e ^} /proc/mounts)"
            fi
            log 'Unmounting already mounted partitions assosiated with the image:'
            # sudo umount -vA "${tmploop[@]}" || return $?
            # Use separate command for each loop device because "umount -A" does not work correctly with multiple devices on single command
            for tmp in "${tmploop[@]}"; do
                sudo umount -v --all-targets "${tmp}" || return $?
            done
            if [[ "$2" == '--rmdir' ]]; then
                log 'Removing empty mountpoints (keep if non-empty):'
                sudo rmdir -v -- "${tmpmp[@]}"
            fi
        else
            log 'The image is not mounted'
            return 0
        fi
    elif [[ -n "${IMG_MOUNTPOINTS[*]}" ]]; then  # Unmount all existing image mount points
        log 'Unmounting image partitions:'
        sudo umount -v --all-targets --recursive "${IMG_MOUNTPOINTS[@]}" || return $?
        if [[ "$1" == '--rmdir' ]]; then
            log 'Removing empty mountpoints (keep if non-empty):'
            sudo rmdir -v -- "${IMG_MOUNTPOINTS[@]}"
        fi
    else
        return 1
    fi
    return 0
}


##
# Create disk image from the source disk image.
# Generally works with globall variables.
##
create_image() {
    local tmp o i v l m t out

    cd "${WORK_DIR}" || quit 1 "Failed to change directory to WORK_DIR: ${WORK_DIR}"
    log "Current work dir: ${WORK_DIR}"

    ## Create/be_sure sparse Raspbian exists
    if [[ -f "${RASPBIAN_IMG}" ]]; then
        if [[ "${RASPBIAN_IMG}" -ef "${RASPBIAN_NAME}" ]]; then
            # The same file or hardlinks to the same file

            # Check if it's already sparse
            # shellcheck disable=2034,2162
            read real_sz tmp tmp tmp tmp sz tmp <<<"$(exec -c ls -ls "${RASPBIAN_IMG}")"
            if [[ ${real_sz} -eq ${sz} ]]; then
                log 'Sparsifying existing Raspbian image...'
                fallocate -vd -- "${RASPBIAN_NAME}" || quit 1 'Failed to sparsify'
            fi
        else
            log 'Copying and sparsifying existing Raspbian image...'
            cp --sparse=always -vT "${RASPBIAN_IMG}" "${RASPBIAN_NAME}" || quit 1 'Failed to copy'
        fi
    else
        log 'Downloading Raspbian image and sparsify it on the fly...'
        ## Do with multiple steps (commented)
        # # shellcheck disable=2086
        # wget -q --show-progress ${WGET_TIMEOUTS} "${SOURCE_IMAGE_URL}" -O "${RASPBIAN_NAME}.zip" || quit 2 "Failed to download Raspbian image: ${SOURCE_IMAGE_URL}"
        # IMG=$(exec -c zipinfo -1 "${RASPBIAN_NAME}.zip")
        # unzip "${RASPBIAN_NAME}.zip"
        # rm -vf -- "${RASPBIAN_NAME}.zip"
        # # Make it sparse to reduce real image size (~30-50%)
        # cp --sparse=always -vT "${IMG}" "${RASPBIAN_NAME}"
        # rm -vf -- "${IMG}"

        ## Alternatively do all on the fly supposing that it's only single file inside zip archive.
        if ((KEEP_SRC_IMAGE)); then
            log 'Creating image replica on downloading...'
            # shellcheck disable=2086
            wget -q --show-progress ${WGET_TIMEOUTS} "${SOURCE_IMAGE_URL}" -O- \
                | bsdtar -xOf- \
                | tee >(cp --sparse=always -T /dev/stdin "${RASPBIAN_NAME}.replica") \
                      | cp --sparse=always -T /dev/stdin "${RASPBIAN_NAME}"
        else
            # shellcheck disable=2086
            wget -q --show-progress ${WGET_TIMEOUTS} "${SOURCE_IMAGE_URL}" -O- \
                | bsdtar -xOf- \
                | cp --sparse=always -T /dev/stdin "${RASPBIAN_NAME}"
        fi
        for i in "${PIPESTATUS[@]}"; do
            ((i==0)) || quit 2 'Failed to download and sparsify Raspbian image'
        done
        sync
    fi

    ## Check if the image has 2nd partition
    out=$(exec -c sfdisk --color=never -l -- "${RASPBIAN_NAME}")
    if ! grep -qe "^${RASPBIAN_NAME}2 " <<<"${out}"; then
        quit 4 "Raspbian image is broken (has no 2nd partition or failed to check it)"
    fi

    log "Resulting image will be based on this Raspbian image:"
    echo "${out/$'\n'$'\n'/$'\n'}"  # With empty lines removed

    log 'Making disk image...'
    PI_IMG="${RASPBIAN_NAME%.img}.pi-${PI_IMAGE_VERSION}.img"
    if ((KEEP_SRC_IMAGE)); then
        if  [[ -f "${RASPBIAN_NAME}.replica" && \
            $(exec -c stat --printf="%s" -- "${RASPBIAN_NAME}") \
            -eq \
            $(exec -c stat --printf="%s" -- "${RASPBIAN_NAME}.replica") \
            ]]; then
            # Comparison by size should be enough here because images was downloaded simultaneously
            # and names are also pretty similar.
            # Checksum comparison is reliable but slow and considered redundant.
            log "Rename Raspbian image replica"
            mv -vfT "${RASPBIAN_NAME}.replica" "${PI_IMG}" || quit 1 'Failed to rename'
        else
            log "Cloning base Raspbian image to: ${PI_IMG}"
            # dd is faster than cp because of higher block size (and can show
            # progress) but final real image size will be slightly higher.
            dd "${DD_BS}" "if=${RASPBIAN_NAME}" "of=${PI_IMG}" "conv=${DD_CONV_FSYNC},sparse" ${DD_STATUS} || quit 1 'Failed to clone'
            # cp -vT "${RASPBIAN_NAME}" "${PI_IMG}" || quit 1 'Failed to clone'
        fi
    else
        log 'Rename base Raspbian image'
        mv -vfT "${RASPBIAN_NAME}" "${PI_IMG}" || quit 1 'Failed to rename'
    fi
    IMG=${PI_IMG}
    # Now PI_IMG and IMG vars are the same

    gather_image_info "${IMG}"

    ## Check rootfs before mounting
    log 'Create loop device for rootfs partition'
    unset ROOT_LODEV
    ROOT_LODEV=$(exec -c sudo losetup -f --show -o $((IMG_PART_START[ROOT_PART_NUM-1]*IMG_BS)) "${IMG}")
    # shellcheck disable=2181
    [[ $? -eq 0 && -n "${ROOT_LODEV}" ]] || quit 1 'Failed to create loop device for rootfs'

    log 'Check rootfs filesystem for errors and preen'
    sudo e2fsck -pf "${ROOT_LODEV}" || { sudo losetup -d "${ROOT_LODEV}"; quit 1 'Failed to preen filesystem'; }
    sync

    log 'Detach rootfs loop device'
    sudo losetup -d "${ROOT_LODEV}" || log 'WARNING: Failed to detach rootfs loop device'

    mount_img "${IMG}"

    log 'Configuring disk image...'
    # TODO: Apply changes for any initial username, not just "pi"
    if [[ -n "${PI_USERNAME}" && "${PI_USERNAME}" != 'pi' ]]; then
        log "Rename \"pi\" user to \"${PI_USERNAME}\" (keep UID) and change all related files/dirs except /etc/sudoers.d/010_pi-nopasswd"
        # shellcheck disable=1083
        sudo mv -vf "${IMG_ROOT_MOUNTPOINT}/home/"{pi,"${PI_USERNAME}"}
        sudo sed -i -e "s|^pi:|${PI_USERNAME}:|" -e "s|:/home/pi:|:/home/${PI_USERNAME}:|" "${IMG_ROOT_MOUNTPOINT}/etc/"{passwd,shadow}
        sudo sed -i \
            -e "s|^pi:|${PI_USERNAME}:|g" \
            -e "s|:pi\$|:${PI_USERNAME}|g" \
            -e "s|:pi,|:${PI_USERNAME},|g" \
            -e "s|,pi,|,${PI_USERNAME},|g" \
            -e "s|,pi\$|,${PI_USERNAME}|g" \
            "${IMG_ROOT_MOUNTPOINT}/etc/"{group,gshadow}
        sudo sed -i -e "s|^pi:|${PI_UID}:|" "${IMG_ROOT_MOUNTPOINT}/etc/subuid"
        sudo sed -i -e "s|^pi:|${PI_GID}:|" "${IMG_ROOT_MOUNTPOINT}/etc/subgid"
        echo changed: $'\n'"  ${IMG_ROOT_MOUNTPOINT}/etc/"{passwd,shadow,group,gshadow,subuid,subgid}
    fi

    if [[ -n "${ROOTFS_CHANGES_DIR}" ]]; then
        log "Applying rootfs changes from this dir: ${ROOTFS_CHANGES_DIR}"
        log "INFO: All copied files will be owned by root and has the same permissions"

        # If hidden files present dotglob required
        # shopt -q dotglob || shopt -s dotglob  # Set dotglob if not set globally, need to revert after cp if changed.
        sudo cp -r --preserve=mode --no-preserve=ownership,timestamps -t "${IMG_ROOT_MOUNTPOINT}" "${ROOTFS_CHANGES_DIR}/"* || quit 7 'Failed to apply changes to rootfs'
    fi

    if [[ -n "${ROOTFS_CHANGES_TARBALL}" ]]; then
        log "Applying rootfs changes from tarball: ${ROOTFS_CHANGES_TARBALL}"
        sudo tar xaf "${ROOTFS_CHANGES_TARBALL}" -C "${IMG_ROOT_MOUNTPOINT}" || quit 7 'Failed to apply tarball changes to rootfs'
    fi

    if [[ -n "${PI_IMAGE_VERSION_FILE}" ]]; then
        log "Write the image version ${PI_IMAGE_VERSION} to ${PI_IMAGE_VERSION_FILE}"
        echo "${PI_IMAGE_VERSION}" | sudo tee "${IMG_ROOT_MOUNTPOINT}${PI_IMAGE_VERSION_FILE}" &>/dev/null
    fi

    log 'Mount temporary directory for apt cache to save disk space'
    sudo mkdir -p "${TMP_DIR}/cache/apt"
    sudo mount -o bind "${TMP_DIR}/cache/apt" "${IMG_ROOT_MOUNTPOINT}/var/cache/apt"

    log 'Implementing changes in chroot environment...'
    # TODO: (?) Avoid chroot to support build on any host avoiding "the same CPU arch" restriction.
    #       Candidates to consider: qemu, debootstrap, dpkg --root
    sudo chroot "${IMG_ROOT_MOUNTPOINT}" /bin/bash -s <<EOFCHROOTCMD
# This block is a root shell inside the image rootfs partition
# Boot partition (if any) have to be mounted/binded to corresponding dir.
# Variables with escaped dollar sign are local for chroot.
# Variables with unescaped dollar sign will be substituted before execution.

export LC_ALL=C
export DEBIAN_FRONTEND='noninteractive'

APT_DIST_UPGRADE="${APT_DIST_UPGRADE}"
APT_UPGRADE="${APT_UPGRADE}"
APT_AUTOREMOVE="${APT_AUTOREMOVE}"

log() { printf "%(${TIMESTAMP_FORMAT})T %5d %s\n" '-1' \$\$ "CHROOT: \$*"; }

log 'Clean apt cache'
apt-get clean

log 'Update repo packages index files'
apt-get -q update

# TODO: Support to remove/purge any packages
# log 'Purge dhcpcd* and remove its files'
# apt-get -yq -o Dpkg::Use-Pty=0 -o Dpkg::Options::="--force-confdef" -o Dpkg::Options::="--force-confold" purge "dhcpcd*"
# rm -vrf /etc/dhcpcd.conf /etc/systemd/system/dhcpcd.service.d

if ((APT_DIST_UPGRADE)); then
    log 'Upgrade system: apt-get dist-upgrade'
    apt-get -yq --allow-downgrades --allow-remove-essential --allow-change-held-packages -o Dpkg::Options::="--force-confdef" -o Dpkg::Options::="--force-confold" dist-upgrade
elif ((APT_UPGRADE)); then
    log 'Upgrade packages: apt-get upgrade'
    apt-get -yq --allow-downgrades --allow-remove-essential --allow-change-held-packages -o Dpkg::Options::="--force-confdef" -o Dpkg::Options::="--force-confold" upgrade
fi

log 'Clean apt cache'
apt-get clean

log 'Update repo packages index files'
apt-get -q update

log 'Installing required packages...'
# TODO: In general case need to preliminary extend rootfs partition and filesystem
#       to get rid of "No space left" if too much packages to install.
apt-get -yq --allow-unauthenticated --allow-downgrades --allow-remove-essential --allow-change-held-packages -o Dpkg::Use-Pty=0 -o Dpkg::Options::="--force-confdef" -o Dpkg::Options::="--force-confold" install ${APT_EXTRA_PKGS//$'\n'/ }

if ((APT_AUTOREMOVE)); then
    log 'Remove packages that were automatically installed to satisfy dependencies for other packages and no longer needed'
    apt-get -yq autoremove
fi

log 'Clean apt cache'
apt-get clean

log 'Exit from chroot environment'
exit 0
EOFCHROOTCMD
    # shellcheck disable=2162,2181
    if (($?)); then
        log "ERROR: Failed to chroot! This host and image target CPU architectures may be incompatible."
        sudo umount -p "${IMG_ROOT_MOUNTPOINT}/var/cache/apt"
        sudo rm -rvf -- "${TMP_DIR}/cache"
        quit 222
    fi

    # log 'Clean apt cache on the image'
    # sudo apt-get -o RootDir="${IMG_ROOT_MOUNTPOINT}" clean
    # # # Analogue of 'apt-get clean' in chroot
    # # for f in "${IMG_ROOT_MOUNTPOINT}/var/cache/apt/archives/"{,partial/}*; do
    # #     case "${f##*/}" in
    # #         lock|partial|'*') ;;
    # #         *) sudo rm -rvf -- "${f}";;
    # #     esac
    # # done

    log 'Unmount temporary directory for apt cache and clean'
    sudo umount -p "${IMG_ROOT_MOUNTPOINT}/var/cache/apt"
    sudo rm -rvf -- "${TMP_DIR}/cache"

    if [[ -n "${EARLY_BOOT_SSH}" && -d "${IMG_BOOT_MOUNTPOINT}" ]]; then
        case "${EARLY_BOOT_SSH}" in
            0)  log 'Force disabling SSH server on early boot stage'
                [[ -f "${IMG_BOOT_MOUNTPOINT}/ssh" ]] && sudo rm -vf -- "${IMG_BOOT_MOUNTPOINT}/ssh"
                ;;
            1)  log 'Force enabling SSH server on early boot stage'
                [[ -f "${IMG_BOOT_MOUNTPOINT}/ssh" ]] || sudo touch "${IMG_BOOT_MOUNTPOINT}/ssh"
                ;;
        esac
    elif [[ -n "${EARLY_BOOT_SSH}" && -z "${IMG_BOOT_MOUNTPOINT}" ]]; then
        log "WARNING: Failed to configure EARLY_BOOT_SSH: boot mountpoint does not exist"
    fi

    if [[ -n "${DEFAULT_PI_PASSWORD}" ]]; then
        log "Change \"${PI_USERNAME}\" user password to: ${DEFAULT_PI_PASSWORD}"
        sudo sed -i "s|^${PI_USERNAME}:[^:]*:|${PI_USERNAME}:$(exec -c mkpasswd -m sha-512 -s <<<"${DEFAULT_PI_PASSWORD}"):|" "${IMG_ROOT_MOUNTPOINT}/etc/shadow"
    fi

    log 'Be sure ~/.ssh folder exists for default user with correct permissions'
    sudo mkdir -p "${IMG_ROOT_MOUNTPOINT}/home/${PI_USERNAME}/.ssh"
    sudo chown "${PI_UID}:${PI_GID}" "${IMG_ROOT_MOUNTPOINT}/home/${PI_USERNAME}/.ssh"
    sudo chmod 700 "${IMG_ROOT_MOUNTPOINT}/home/${PI_USERNAME}/.ssh"

    log 'Obtaining Linux kernel release of the image...'
    # TODO: now it works with Raspbian only
    if [[ -n "${IMG_BOOT_MOUNTPOINT}" && -f "${IMG_BOOT_MOUNTPOINT}/kernel7.img" ]]; then
        kernel_img="${IMG_BOOT_MOUNTPOINT}/kernel7.img"
    elif [[ -f "${IMG_ROOT_MOUNTPOINT}/kernel7.img" ]]; then
        kernel_img="${IMG_ROOT_MOUNTPOINT}/kernel7.img"
    else
        # TODO: try to find kernel image thoroughly
        kernel_img=''
    fi
    if [[ -n "${kernel_img}" ]]; then
        kernel_skip=$(exec -c grep -abo $'\x1f\x8b\x08\x00\x00\x00\x00\x00' "${kernel_img}" 2>/dev/null)
        kernel_skip=${kernel_skip%%:*}
        # Calculate max bs to speedup dd read
        for ((bs=1024;bs>1;bs/=2)); do ((kernel_skip/bs*bs == kernel_skip)) && break; done
        kernel_release=$(dd "if=${kernel_img}" "bs=${bs}" "skip=$((kernel_skip/bs))" | zgrep -aom1 'Linux version [^ ]\+' 2>/dev/null)
        kernel_release=${kernel_release#Linux version }  # Have to be the same as 'uname -r' in chroot
        if ! [[ "${kernel_release}" =~ ^[0-9a-z._-+]$ ]]; then
            log "Linux kernel release: ${kernel_release}"
            log 'Remove unused directories with kernel modules:'
            for i in "${IMG_ROOT_MOUNTPOINT}"/lib/modules/*; do
                if [[ "${kernel_release}" != "${i##*/}" ]]; then
                    sudo rm -rf -- "${i:?}"/*  # Avoid verbose deletion
                    sudo rm -rvf -- "${i:?}"  # Verbose deletion only for dir
                fi
            done
        else
            log "Linux kernel release is unknown"
        fi
    else
        log "Linux kernel image not found"
    fi

    # read -r PI_IMAGE_DEBIAN_VERSION_MAJOR <"${IMG_ROOT_MOUNTPOINT}/etc/debian_version"
    # PI_IMAGE_DEBIAN_VERSION_MAJOR=${PI_IMAGE_DEBIAN_VERSION_MAJOR%%[/\.]*}
    # PI_IMAGE_DEBIAN_VERSION_MAJOR=${PI_IMAGE_DEBIAN_VERSION_MAJOR,,}  # To lowercase
    # log "Image major Debian version is ${PI_IMAGE_DEBIAN_VERSION_MAJOR}"
    # case "${PI_IMAGE_DEBIAN_VERSION_MAJOR}" in
    #     8|jessie) quit 1 "Debian 8 (Jessie) is no longer supported. Use newer OS image.";;
    #     9|stretch) PI_IMAGE_DEBIAN_VERSION_MAJOR=9;;
    #     *)  # Failed to detect
    #         # PI_IMAGE_DEBIAN_VERSION_MAJOR=0
    #         log "WARNING: Unsupported image Debian version (${PI_IMAGE_DEBIAN_VERSION_MAJOR}), it can be incompatible with this tool!"
    #         ;;
    # esac

    # log 'Remove files related to non RPi 3B from boot partition (to decrease final image size)'
    # sudo rm -vf -- "${IMG_BOOT_MOUNTPOINT}/"{bcm270*.dtb,bcm2710-rpi-cm3.dtb,kernel.img}

    # log 'Truncate logs and other history files'
    # sudo find "${IMG_ROOT_MOUNTPOINT}" -type f -iname '*.log' -o -name '.wget-hsts' -exec truncate -cs0 {} \; -print

    # log 'Remove existing ssh server keys (will be regenerated on first start)'
    # sudo rm -vf -- "${IMG_ROOT_MOUNTPOINT}"/etc/ssh/ssh_host_*

    log 'Zeroying empty space to minimize real size of the final sparse image...'
    if hash zerofree 2>/dev/null; then  # If zerofree utility exists (faster for ext* filesystems)
        ((INTERACTIVE)) && v='-v' || v=''  # v is verbose option for zerofree
        read -rd '' proc_mounts </proc/mounts
        for o in "${IMG_MOUNTPOINTS[@]}"; do
            # Get filesystem type: ${t}
            while read l m t _; do  # lodev mountpoint fstype
                [[ "${m}" == "${o}" ]] && break
            done <<<"${proc_mounts}"

            if [[ -n "${l}" ]] \
            && [[ "${t}" == ext4 || "${t}" == ext3 || "${t}" == ext2 ]]; then
                # zerofree requires readonly or unmounted device
                sudo mount -o remount,ro "${l}"
                sudo zerofree $v "${l}"
            else
                sudo dd if=/dev/zero "of=${o}/0.tmp" "bs=${IMG_BS}" ${DD_STATUS} "conv=${DD_CONV_FSYNC}"
                sudo rm -vf -- "${o}/0.tmp"
            fi
            unset l m t
        done
    else  # No zerofree utility
        for o in "${IMG_MOUNTPOINTS[@]}"; do
            sudo dd if=/dev/zero "of=${o}/0.tmp" "bs=${IMG_BS}" ${DD_STATUS} "conv=${DD_CONV_FSYNC}"
            sudo rm -vf -- "${o}/0.tmp"
        done
    fi

    log 'Sparsifying final image in place...'
    fallocate -vd -- "${IMG}" || log 'ERROR: Failed to sparsify'

    umount_img "${IMG}" --rmdir || log 'ERROR: Failed to unmount image partitions.'

    if ((SHRINK_ROOTFS)); then
        log 'Shrinking rootfs filesystem and partition to minimize final image virtual size...'

        gather_image_info "${IMG}"

        # log 'Create loop device(s) from partitions without mounting'
        # unset LODEV
        # LODEV=()  # define empty array
        # for ((i=0;i<${#IMG_PART_START[@]};++i)); do
        #     LODEV+=("$(exec -c sudo losetup -f --show -o $((IMG_PART_START[i]*IMG_BS)) "${IMG}")")
        # done
        # ROOT_LODEV=${LODEV[$((ROOT_PART_NUM-1))]}
        # [[ -n "${ROOT_LODEV}" ]] || quit 1 'Failed to create loop device for rootfs'
        log 'Create loop device for rootfs partition'
        unset ROOT_LODEV
        ROOT_LODEV=$(exec -c sudo losetup -f --show -o $((IMG_PART_START[ROOT_PART_NUM-1]*IMG_BS)) "${IMG}")
        [[ -n "${ROOT_LODEV}" ]] || quit 1 'Failed to create loop device for rootfs'

        log 'Check rootfs filesystem for errors and preen'
        sudo e2fsck -pf "${ROOT_LODEV}" || quit 1 'Failed to preen rootfs'
        sync

        log 'Shrink rootfs filesystem'
        sudo resize2fs -M "${ROOT_LODEV}" | grep -v -e '^resize2fs ' -e '^$'
        ((PIPESTATUS[0]==0)) || quit 1 'Failed to shrink rootfs filesystem'
        sync

        log 'Shrink rootfs partition'
        # shellcheck disable=2162
        { read _ _ BC; read _ _ BS; } <<<"$(LC_ALL=C sudo tune2fs -l "${ROOT_LODEV}" | grep -e '^Block count:' -e '^Block size:')"
        IMG_LODEV=$(exec -c sudo losetup -f --show "${IMG}")
        [[ -n "${IMG_LODEV}" ]] || quit 1 'Failed to create loop device for the image'
        LC_ALL=C sudo sfdisk "${IMG_LODEV}" -N "${#IMG_PART[@]}" <<<"size=$((BC*BS/IMG_BS))" 2>&1 \
        | grep -v \
            -e '^Re-reading the partition table failed' \
            -e '^The kernel still uses the old table' \
            -e '^Calling ioctl() to re-read partition table' \
            -e '^$'
        ((PIPESTATUS[0]==0)) || quit 1 'Failed to shrink rootfs partition'
        sync

        log 'Detach just created loop devices'
        # sudo losetup -d "${LODEV[@]}" "${IMG_LODEV}"
        sudo losetup -d "${ROOT_LODEV}" "${IMG_LODEV}" || quit 1 'Failed to detach loop devices'

        log 'Truncating the image (remove trailing unused space)'
        IFS=$'\n' read -r -d '' _ e <<<"$(exec -c sudo sfdisk --color=never -q -l -o end -- "${IMG}")"  # Get End value
        sudo truncate -s $((++e*IMG_BS)) "${IMG}" || quit 1 'Failed to truncate'
        sync

        log 'Mount and unmount the image to be sure that the image is valid after shrinking'
        mount_img "${IMG}" || quit 1 "Failed to mount the image. Rootfs shrinking failed."
        umount_img "${IMG}" --rmdir || quit 1 "Failed to unmount the image. Rootfs shrinking failed."

        log 'Shrinking of rootfs completed'
    fi

    log "Disk image created: ${PI_IMG}"

    if ((TAR_PACK)); then
        log "Creating disk image tar archive with xz compressor options: ${XZ_OPT}"
        tar caS -f "${PI_IMG}.txz" "${PI_IMG}"  # XZ_OPT is already exported
        # shellcheck disable=2181
        if (($?==0)); then
            log "Archive created: ${PI_IMG}.txz"
        else
            log 'ERROR: Failed to create tar archive'
        fi
    fi
}


##
# Flash existing disk image to SD card with additional changes on just flashed SD card
##
flash_image() {
    local IMG dev tmp
    IMG=$1  # Must be already valid

    # Do some heavy postflashing steps here in background so the results are ready
    # when postflashing stage comes (or at least partially done).
    if ((POST_FLASHING)); then
        if ((CERT_GENERATE)); then
            log 'Creating SSL certs in background for post flashing actions...'
            # $$ below is this process PID

            CERT_DH="${TMP_DIR}/$$.dh.pem"
            openssl dhparam -outform PEM -out "${CERT_DH}" "${CERT_DH_SZ}" 2>/dev/null &

            CERT_MAIN="${TMP_DIR}/$$.main"
            openssl req -x509 -nodes -days "${CERT_VALID_DAYS}" -newkey rsa:2048 -keyout "${CERT_MAIN}.key" -out "${CERT_MAIN}.crt" -subj "${CERT_SUBJ}" 2>/dev/null &

            CERT_ANY="${TMP_DIR}/$$.any"
            openssl req -x509 -nodes -days "${CERT_VALID_DAYS}" -newkey rsa:2048 -keyout "${CERT_ANY}.key" -out "${CERT_ANY}.crt" -subj "${CERT_SUBJ}" 2>/dev/null &
        fi
    fi

    ask_for_sudo_password

    [[ -z "${ROOT_PART_NUM}" ]] && gather_image_info "${IMG}"  # Required to autodetect ROOT_PART_NUM

    # Unmount existing SD card partitions if any
    unmount_mounted_partitions "${SDCARD}" || quit 22 'Failed to unmount device partition(s)'

    if ((FLASH)); then
        # TODO: consider blkdiscard with --zeroout and/or --secure for some cases
        if ((SDCARD_ERASE_ON_FLASH)); then
            if ! [[ -e "${SDCARD_ERASE_ON_FLASH_SRC}" ]]; then
                quit 202 "No such file: ${SDCARD_ERASE_ON_FLASH_SRC}"
            elif ! [[ -c "${SDCARD_ERASE_ON_FLASH_SRC}" ]]; then
                # log "WARNING: Erasing source device is not a character special device. Fallback to /dev/zero"
                # SDCARD_ERASE_ON_FLASH_SRC='/dev/zero'
                log "INFO: Erasing source is not a character special device"
            fi
            log "Erasing SD card before flashing using ${SDCARD_ERASE_ON_FLASH_SRC}"
            TS=${SECONDS}
            sudo dd "if=${SDCARD_ERASE_ON_FLASH_SRC}" "of=${SDCARD}" ${DD_BS} ${DD_STATUS} ${DD_OFLAG} 'iflag=fullblock' "conv=${DD_CONV_FSYNC}"
            log "Erasing completed in $((SECONDS-TS))s"

            # Speedup image flashing to zeroed SD card using conv=sparse
            if [[ "${SDCARD_ERASE_ON_FLASH_SRC}" == /dev/zero ]]; then
                if [[ -z "${DD_CONV}" ]]; then
                    DD_CONV='sparse'
                elif ! [[ "${DD_CONV}" =~ conv=.*sparse.* ]]; then
                    DD_CONV+=',sparse'
                fi
            fi
        fi

        # To fix external automounting tools issues
        unmount_mounted_partitions "${SDCARD}" || quit 22 'Failed to unmount device partition(s)'

        log 'Discarding all SD card sectors to increase endurance and performance (wear-leveling)'
        sudo blkdiscard -v "${SDCARD}" || log 'WARNING: Some USB cardreaders may not support discard call, native SD cardreader is recommended.'

        log "Flashing the image (dd ${DD_BS} ${DD_CONV} ${DD_OFLAG} ${DD_STATUS})..."
        TS=${SECONDS}
        sudo dd "if=${IMG}" "of=${SDCARD}" ${DD_BS} ${DD_CONV} ${DD_OFLAG} ${DD_STATUS} || quit 23 'Failed to flash the image'
        log "Flashing completed in $((SECONDS-TS))s"

        if ((SDCARD_VERIFY_INTEGRITY)); then
            log 'Verifying intergity of just written image'
            if sudo cmp --print-bytes --bytes="$(exec -c stat --format='%s' "${IMG}")" "${IMG}" "${SDCARD}"; then
                log "Integrity verified"
            else
                quit 202 "Integrity test failed. SD card can be corrupted or flashed with incorrect options."
            fi
        fi

        if ((SDCARD_CHECK_ROOTFS_FOR_ERRORS)); then
            reread_partitions "${SDCARD}"

            # Read SDCARD all partitions to SDCARD_PART
            { read; IFS=$'\n' read -r -d '' -a SDCARD_PART; } <<<"$(exec -c sudo sfdisk -q -l -o device -- "${SDCARD}")"

            if ! [[ -n "${SDCARD_PART[*]}" && -b "${SDCARD_PART[0]}" ]]; then
                quit 202 "Cannot find partitions on SD card: ${SDCARD}"
            fi

            if ((ROOT_PART_NUM)); then
                log 'Checking rootfs filesystem for errors...'
                sudo e2fsck -nf "${SDCARD_PART[$((ROOT_PART_NUM-1))]}" | tail -n 10
                ((PIPESTATUS[0]==0)) || quit 1 'Rootfs is not clean after flashing! The image file or SD card might be corrupted or flashed with incorrect options.'
            fi
        fi
    fi


    # Stop here if post flashing actions disabled
    ((POST_FLASHING)) || return 0
    log 'Start post flashing actions...'
    TS=${SECONDS}

    ## Resizing rootfs to fill SD card
    # TODO: consider to keep some unpartitioned space as Armbian do for performance reasons:
    # https://forum.armbian.com/topic/3776-the-partition-is-not-resized-to-full-sd-card-size/?do=findComment&comment=27413
    if ((EXPAND_ROOTFS)); then
        # Rootfs resizing can sppedup first boot and/or
        # help when cloned image is used as a source with auto resizing by OS already disabled.
        # It's analog of local /usr/lib/raspi-config/init_resize.sh + /etc/init.d/resize2fs_once
        log 'Start rootfs resizing to fill SD card...'
        ts=${SECONDS}

        reread_partitions "${SDCARD}"

        SDCARD_PARTITION_TABLE=$(exec -c sudo parted -sm "${SDCARD}" unit s print)
        SDCARD_NAME=${SDCARD##*/}
        read -r SDCARD_SZ <"/sys/block/${SDCARD_NAME}/size"  # Size in blocks

        # SDCARD_ID=$(sudo xxd -s 440 -ps -l 4 "${SDCARD}" | sed -e 's/\(..\)\(..\)\(..\)\(..\)/\4\3\2\1/g')
        # SDCARD_ID="$(LC_ALL=C sudo sfdisk --color=never -l -- "${SDCARD}" | sed -n 's|Disk identifier: 0x\([0-9a-fA-F]*\)|\1|p')"
        SDCARD_ID="$(sudo sfdisk -d -- "${SDCARD}" | sed -n 's|label-id: \(0x\)\?\([0-9a-fA-F]*\)|\2|p')"

        SDCARD_LAST_PART_NUM=${SDCARD_PARTITION_TABLE##*$'\n'}
        SDCARD_LAST_PART_NUM=${SDCARD_LAST_PART_NUM%%:*}

        # Detect SDCARD partitions
        { read; IFS=$'\n' read -r -d '' -a SDCARD_PART; } <<<"$(exec -c sudo sfdisk -q -l -o device -- "${SDCARD}")"

        if ! [[ -n "${SDCARD_PART[*]}" && -b "${SDCARD_PART[0]}" ]]; then
            quit 202 "Cannot find partitions on SD card: ${SDCARD}"
        fi

        # SDCARD_PART[N] aliases
        SDCARD_PART_ROOT="${SDCARD_PART[$((ROOT_PART_NUM-1))]}"
        if ((BOOT_PART_NUM)); then
            SDCARD_PART_BOOT="${SDCARD_PART[$((BOOT_PART_NUM-1))]}"
        else
            SDCARD_PART_BOOT=''
        fi

        IMG_ROOT_MOUNTPOINT="${MOUNT_DIR}/${SDCARD_PART_ROOT##*/}"
        IMG_MOUNTPOINTS=("${IMG_ROOT_MOUNTPOINT}")
        if [[ -n "${SDCARD_PART_BOOT}" ]]; then
            IMG_BOOT_MOUNTPOINT="${MOUNT_DIR}/${SDCARD_PART_BOOT##*/}"
            # IMG_ROOT_MOUNTPOINT must be specified last, so prependd.
            IMG_MOUNTPOINTS=("${IMG_BOOT_MOUNTPOINT}" "${IMG_MOUNTPOINTS[@]}")
        else
            IMG_BOOT_MOUNTPOINT=''
        fi

        log 'Creating paths for mounting (if required)'
                mkdir -vp "${IMG_MOUNTPOINTS[@]}" 2>/dev/null \
        || sudo mkdir -vp "${IMG_MOUNTPOINTS[@]}"

        if [[ -z "${ROOT_PART_NUM}" ]]; then
            log 'WARNING: ROOT_PART_NUM is unknown, cannot expand rootfs. Set explicitly by "--root-part-num".'
        elif ((SDCARD_LAST_PART_NUM == ROOT_PART_NUM)); then
            # To fix third party automounting issues
            unmount_mounted_partitions "${SDCARD}" || quit 22 'Failed to unmount device partition(s)'

            log 'Resizing rootfs partition to fill full SD card space'
            ((INTERACTIVE)) && o='' || o='-s'
            sudo parted ${o} -m "${SDCARD}" u s resizepart "${ROOT_PART_NUM}" "$((SDCARD_SZ-1))" || quit 1 'Failed to expand rootfs'
            sync

            reread_partitions "${SDCARD}"

            # SDCARD_ID_NEW="$(LC_ALL=C sudo sfdisk --color=never -l -- "${SDCARD}" | sed -n 's|Disk identifier: 0x\([0-9a-fA-F]*\)|\1|p')"
            SDCARD_ID_NEW="$(sudo sfdisk -d -- "${SDCARD}" | sed -n 's|label-id: \(0x\)\?\([0-9a-fA-F]*\)|\2|p')"

            # Work with boot partition if exists
            if [[ -n "${SDCARD_PART_BOOT}" && -n "${IMG_BOOT_MOUNTPOINT}" ]]; then
                if sudo mount -v "${SDCARD_PART_BOOT}" "${IMG_BOOT_MOUNTPOINT}"; then
                    # /boot/cmdline.txt is Raspbian specific
                    if [[ -f "${IMG_BOOT_MOUNTPOINT}/cmdline.txt" ]]; then
                        log 'Remove init=/usr/lib/raspi-config/init_resize.sh from /boot/cmdline.txt'
                        sudo sed -i 's| init=/usr/lib/raspi-config/init_resize.sh||' "${IMG_BOOT_MOUNTPOINT}/cmdline.txt"

                        if ! grep -Fq splash "${IMG_BOOT_MOUNTPOINT}/cmdline.txt"; then
                            log 'Remove quiet from /boot/cmdline.txt because splash specified'
                            sudo sed -i "s| quiet[ $]| |g" "${IMG_BOOT_MOUNTPOINT}/cmdline.txt"
                        fi

                        log "Fix rootfs PARTUUID in /boot/cmdline.txt from ${SDCARD_ID} to ${SDCARD_ID_NEW}"
                        sudo sed -i "s|${SDCARD_ID}|${SDCARD_ID_NEW}|" "${IMG_BOOT_MOUNTPOINT}/cmdline.txt"

                        IFS='' read -rd '' cmdline_txt <"${IMG_BOOT_MOUNTPOINT}/cmdline.txt"
                        log "Content of ${IMG_BOOT_MOUNTPOINT}/cmdline.txt:"$'\n'"${cmdline_txt}"
                        unset cmdline_txt
                    else
                        log "INFO: /boot/cmdline.txt not found, skipping setup."
                    fi

                    if [[ -f "${IMG_BOOT_MOUNTPOINT}/config.txt" ]]; then
                        if ((SD_OVERCLOCK)) && grep -q '^#\s*dtparam=sd_overclock=[0-9]*' "${IMG_BOOT_MOUNTPOINT}/config.txt"; then
                            log "Enable SD card overclock to ${SD_OVERCLOCK} MHz (only for UHS SD cards)"
                            sudo sed -i -e "s|^#\s*dtparam=sd_overclock=[0-9]*|dtparam=sd_overclock=${SD_OVERCLOCK}|" "${IMG_BOOT_MOUNTPOINT}/config.txt"
                        else
                            log "WARNING: /boot/config.txt not found or incompatible, skipping SD card overclock."
                        fi
                    fi

                    sudo umount -v "${IMG_BOOT_MOUNTPOINT}"
                else
                    quit 203 "Failed to mount boot SD card partition: ${SDCARD_PART_BOOT}"
                fi
            fi

            log 'Check rootfs filesystem for errors and preen'
            sudo e2fsck -pf "${SDCARD_PART_ROOT}" || quit 1 'Failed to preen rootfs filesystem'
            sync

            log 'Resizing rootfs to fill partition...'
            ((INTERACTIVE)) && o='-p' || o=''
            if sudo resize2fs ${o} "${SDCARD_PART_ROOT}"; then
                        mkdir -vp "${IMG_ROOT_MOUNTPOINT}" 2>/dev/null \
                || sudo mkdir -vp "${IMG_ROOT_MOUNTPOINT}"

                if sudo mount -v "${SDCARD_PART_ROOT}" "${IMG_ROOT_MOUNTPOINT}"; then
                    # TODO: handle non PARTUUID entries, e.g. UUID.
                    if [[ "${SDCARD_ID}" != "${SDCARD_ID_NEW}" ]] \
                    && grep -qF "${SDCARD_ID}" "${IMG_ROOT_MOUNTPOINT}/etc/fstab"; then
                        log "Fix rootfs PARTUUID in /etc/fstab from ${SDCARD_ID} to ${SDCARD_ID_NEW}"
                        sudo sed -i "s/${SDCARD_ID}/${SDCARD_ID_NEW}/g" "${IMG_ROOT_MOUNTPOINT}/etc/fstab"
                    fi

                    if [[ -f "${IMG_ROOT_MOUNTPOINT}/etc/init.d/resize2fs_once" ]]; then
                        log "Removing service resize2fs_once"
                        if sudo rm -vf -- "${IMG_ROOT_MOUNTPOINT}/etc/init.d/resize2fs_once"; then
                            # Analog of local command: sudo update-rc.d resize2fs_once remove
                            for f in "${IMG_ROOT_MOUNTPOINT}/etc/rc"[0-6S].d/*; do
                                if [[ "$(exec -c readlink -sen "${f}")" == '/etc/init.d/resize2fs_once' ]]; then
                                    sudo rm -vf -- "${f}"
                                fi
                            done
                        fi
                    fi
                    sudo umount -v "${IMG_ROOT_MOUNTPOINT}"
                else
                    quit 203 "Failed to mount rootfs SD card partition: ${SDCARD_PART_ROOT}"
                fi
            else
                log 'WARNING: Failed to resize rootfs to fill partition'
            fi

            # To fix third party automounting issues
            unmount_mounted_partitions "${SDCARD}" || quit 22 'Failed to unmount device partition(s)'
            # reread_partitions "${SDCARD}"

            log "Resizing rootfs partition to fill full SD card space completed in $((SECONDS-ts))s"
        else
            log "WARNING: Resizing of rootfs to fill SD card not supported: rootfs is not the last partition"
        fi
    fi
    ## END Resizing rootfs to fill SD card


    sudo mount -v "${SDCARD_PART_ROOT}" "${IMG_ROOT_MOUNTPOINT}" || quit 203 "Failed to mount rootfs SD card partition: ${SDCARD_PART_ROOT}"

    if ((REGENERATE_SSH_SERVER_KEYS)); then
        log '[Re]generate SSH server keys'
        for t in rsa ecdsa ed25519; do  # TODO: (?) include dsa
            [[ -f "${IMG_ROOT_MOUNTPOINT}/etc/ssh/ssh_host_${t}_key" ]] && sudo rm -vf -- "${IMG_ROOT_MOUNTPOINT}/etc/ssh/ssh_host_${t}_key"
            sudo ssh-keygen -q -f "${IMG_ROOT_MOUNTPOINT}/etc/ssh/ssh_host_${t}_key" -t "$t" -N ''
            sudo ssh-keygen -l -f "${IMG_ROOT_MOUNTPOINT}/etc/ssh/ssh_host_${t}_key" | sed 's/ root@\w\+//'
        done
    fi

    log "Waiting for background processes to complete..."
    jobs -l
    wait
    if ((CERT_GENERATE)); then
        log 'Moving just generated SSL certificates to rootfs and change permissions'
        sudo mkdir -vp "${IMG_ROOT_MOUNTPOINT}${PI_SSL_DIR}"  # Be sure that this dir exists
        sudo mv -vfT "${CERT_DH}" "${IMG_ROOT_MOUNTPOINT}${PI_SSL_DIR}/dh.pem"
        sudo chown 0:0 "${IMG_ROOT_MOUNTPOINT}${PI_SSL_DIR}/dh.pem"
        sudo chmod 400 "${IMG_ROOT_MOUNTPOINT}${PI_SSL_DIR}/dh.pem"
        sudo mv -vfT "${CERT_MAIN}.key" "${IMG_ROOT_MOUNTPOINT}${PI_SSL_DIR}/main.key"
        sudo mv -vfT "${CERT_MAIN}.crt" "${IMG_ROOT_MOUNTPOINT}${PI_SSL_DIR}/main.crt"
        sudo mv -vfT "${CERT_ANY}.key"  "${IMG_ROOT_MOUNTPOINT}${PI_SSL_DIR}/any.key"
        sudo mv -vfT "${CERT_ANY}.crt"  "${IMG_ROOT_MOUNTPOINT}${PI_SSL_DIR}/any.crt"
        sudo chown 0:0 "${IMG_ROOT_MOUNTPOINT}${PI_SSL_DIR}/"{main,any}.{key,crt}
        sudo chmod 400 "${IMG_ROOT_MOUNTPOINT}${PI_SSL_DIR}/"{main,any}.key
        sudo chmod 444 "${IMG_ROOT_MOUNTPOINT}${PI_SSL_DIR}/"{main,any}.crt
    fi

    sudo umount -v "${IMG_MOUNTPOINTS[@]}"
    sudo rmdir -v -- "${IMG_MOUNTPOINTS[@]}"

    sync
    log "Post flashing actions completed in $((SECONDS-TS))s"
}


##
# Check for script dependencies
##
check_deps() {
    rval=0
    for i in ${DEPENDENCIES}; do
        if ! hash "$i" &>/dev/null; then
            log "ERROR: Required binary not found: $i"
            rval=250
        fi
    done
    for i in ${DEPENDENCIES_OPTIONAL}; do
        if ! hash "$i" &>/dev/null; then
            log "INFO: Optional binary not found: $i"
        fi
    done
    if ((rval)); then
        # log 'Each action require only part of all dependencies, you can proceed without satisfying all of them if you are sure.'
        if hash apt-get &>/dev/null; then  # Debian derivative
            log 'To satisfy dependencies try: pi-img solve-deps'
            log 'Packages with required binaries also can be found by apt-file'
        fi
        # log 'ERROR: Some dependencies are not satisfied!'
    fi
    return ${rval}
}


##
# Find and install required packages for the script
##
solve_deps() {
    ## Get the list if all installed packages
    # for i in ${DEPENDENCIES}; do dpkg -S $(exec -c readlink -sen $(exec -c which $i)); done | cut -d: -f1 | sort -u | xargs
    PKGS='bsdtar coreutils diffutils e2fsprogs f3 grep gzip less mount openssl parted passwd sed sudo util-linux wget whois zerofree'
    ## Install
    log "WARNING: ${ACTION} is experimental!"
    hash apt-get 2>/dev/null || quit 1 'Not a Debian derivative (no apt-get), cannot satisfy dependencies automatically'
    log 'Installing required packages...'
    sudo apt-get update
    if ((INTERACTIVE)); then
        # shellcheck disable=2086
        sudo apt-get install ${PKGS}
        return $?
    else
        # shellcheck disable=2086
        sudo apt-get -yq -o Dpkg::Use-Pty=0 -o Dpkg::Options::="--force-confdef" -o Dpkg::Options::="--force-confold" install ${PKGS}
        # Not using --force-yes successors: --allow-downgrades --allow-remove-essential --allow-change-held-packages
        return $?
    fi
}
### END Functions


ACTION=$1
shift

# Parse some simple actions
case "${ACTION}" in
    create|flash|mount|umount|unmount) ;;  # These actions will be processed later

    check-deps|deps)
        check_deps
        rval=$?
        ((rval==0)) && log 'All dependencies satisfied'
        quit ${rval}
        ;;

    solve-deps)
        solve_deps
        check_deps
        rval=$?
        ((rval==0)) && log 'All dependencies satisfied'
        quit ${rval}
        ;;

    ''|help|--help|usage)
        echo "${USAGE}" >&2
        exit 255
        ;;

    man)
        if hash pager &>/dev/null; then
            pager <<<"${USAGE}"
        else
            echo "${USAGE}"
        fi
        exit $?
        ;;

    version|--version)
        echo "${SCRIPT_VERSION}"
        exit 0
        ;;

    *) quit 1 "Unrecognized action: ${ACTION}"
esac

((LOG_SCRIPT_VERSION)) && log "pi-img version: ${SCRIPT_VERSION}"

# Quick script dependencies check, for least actions only
check_deps || quit $?


# Try to enable builtins (to avoid subprocesses creation, speedup execution)
for i in sleep sync mkdir ln realpath rmdir tee head; do
    enable -f "/usr/lib/bash/${i}" "${i}"
done &>/dev/null


### Parse arguments
# Allow to set IMG and SDCARD for some actions without options
if [[ -n "$1" && "${1::1}" != '-' ]]; then
    case "${ACTION}" in
        flash|mount|umount|unmount)
            IMG=$1
            if ! [[ -f "${IMG}" || -b "${IMG}" ]]; then
                quit 1 "No such file or block device: ${IMG}"
            fi
            shift
            if [[ -n "$1" && "${1::1}" != '-' && "${ACTION}" == 'flash' ]]; then
                SDCARD=$1
                if ! [[ -f "${SDCARD}" || -b "${SDCARD}" ]]; then
                    quit 1 "No such file or block device: ${SDCARD}"
                fi
                shift
            fi
            ;;
    esac
fi

# Clone command line arguments to access them via array indexes, and
# also split long options and arguments on '=' if they're specified as --option=arg
for arg in "$@"; do
    if [[ "${arg}" =~ --[a-z-]+=.+ ]]; then
        ARGS+=("${arg%%=*}" "${arg#*=}")
    else
        ARGS+=("${arg}")
    fi
done
for ((i=0;i<${#ARGS[@]};i++)); do
    case "${ARGS[$i]}" in
        --work-dir|-w)
            WORK_DIR=${ARGS[$((++i))]}
            [[ -d "${WORK_DIR}" ]] || quit 1 "No such directory: ${WORK_DIR}"
            ;;

        --rootfs-changes-dir)
            ROOTFS_CHANGES_DIR=${ARGS[$((++i))]}
            [[ -d "${ROOTFS_CHANGES_DIR}" ]] || quit 1 "No such directory: ${ROOTFS_CHANGES_DIR}"
            ;;

        --rootfs-changes-tarball)
            ROOTFS_CHANGES_TARBALL=${ARGS[$((++i))]}
            [[ -f "${ROOTFS_CHANGES_TARBALL}" ]] || quit 1 "No such file: ${ROOTFS_CHANGES_TARBALL}"
            ;;

        --root-part-num)
            ROOT_PART_NUM=${ARGS[$((++i))]}
            [[ "${ROOT_PART_NUM}" =~ ^[1-9][0-9]*$ ]] || quit 1 "ROOT_PART_NUM is not a positive number: ${ROOT_PART_NUM}"
            ;;

        --boot-part-num)
            BOOT_PART_NUM=${ARGS[$((++i))]}
            [[ "${BOOT_PART_NUM}" =~ ^[1-9][0-9]*$ ]] || quit 1 "BOOT_PART_NUM is not a positive number: ${BOOT_PART_NUM}"
            ;;

        --source-image-url|-u)
            SOURCE_IMAGE_URL=${ARGS[$((++i))]}
            # shellcheck disable=2086
            wget_header=$(exec -c wget -qS --spider ${WGET_TIMEOUTS} "${SOURCE_IMAGE_URL}" 2>&1)
            wget_rcode=$?
            wget_status=${wget_header##* HTTP/1\.[01] }  # tmp
            wget_status=${wget_status##* HTTP/2 }  # tmp
            wget_status=${wget_status%%$'\n'*}  # E.g.: 404 Not Found
            # wget_status_code=${wget_status%% *}  # E.g.: 404
            # wget_status_msg=${wget_status#* }  # E.g.: Not Found
            # If 'Content-Disposition: * filename=' exists
            if [[ -n "${wget_header}" && -z "${wget_header##*Content-Disposition:* filename=*}" ]]; then
                wget_filename=${wget_header##*Content-Disposition:* filename=}  # tmp
                wget_filename=${wget_filename%%$'\n'*}  # E.g.: 2017-09-07-raspbian-stretch-lite.zip
            # If failed to extract using filename= use last Location: value
            elif [[ -n "${wget_header}" && -z "${wget_header##*Location:*}" ]]; then
                wget_filename=${wget_header##*Location:}  # tmp
                wget_filename=${wget_filename%%$'\n'*}  # tmp
                wget_filename=${wget_filename##*/}
            fi
            [[ -z "${wget_filename}" ]] && quit 2 "URL is unavailable (${wget_rcode}: ${wget_status}): ${SOURCE_IMAGE_URL}"
            [[ -z "${SOURCE_IMAGE_URL_FILENAME}" ]] && SOURCE_IMAGE_URL_FILENAME=${wget_filename%\.*}  # With extension removed (probably .zip)
            unset wget_header wget_rcode wget_status wget_filename wget_status_code wget_status_msg
            # Also see "Arguments post processing" block
            ;;
        --raspbian-name|-n)
            RASPBIAN_NAME=${ARGS[$((++i))]}
            [[ -z "${RASPBIAN_NAME/*\/*/}" ]] && quit 1 '--raspbian-name cannot contain /'
            # Also see "Arguments post processing" block
            ;;

        --pi-image-version|-v) PI_IMAGE_VERSION=${ARGS[$((++i))]};;

        --pi-image-version-file) PI_IMAGE_VERSION_FILE=${ARGS[$((++i))]};;

        --mount-dir)
            MOUNT_DIR=${ARGS[$((++i))]%/}  # Strip trailing slash if any
            [[ -d "${MOUNT_DIR}" ]] || quit 1 "No such directory: ${MOUNT_DIR}"
            ;;

        --tmp-dir)
            TMP_DIR=${ARGS[$((++i))]%/}  # Strip trailing slash if any
            [[ -d "${TMP_DIR}" ]] || quit 1 "No such directory: ${TMP_DIR}"
            ;;

        --default-pi-password) DEFAULT_PI_PASSWORD=${ARGS[$((++i))]};;

        --keep-src-image) KEEP_SRC_IMAGE=${ARGS[$((++i))]};;
        -k1|-k) KEEP_SRC_IMAGE=1;;
        -k0)    KEEP_SRC_IMAGE=0;;

        --img|--image)
            IMG=${ARGS[$((++i))]}
            [[ -f "${IMG}" || -b "${IMG}" ]] || quit 1 "No such file or block device: ${IMG}"
            ;;
        --sdcard)
            SDCARD=${ARGS[$((++i))]}
            [[ -b "${SDCARD}" || -c "${SDCARD}" ]] || quit 1 "Not a block or character special device: ${SDCARD}"
            ;;

        --sdcard-erase-on-flash) SDCARD_ERASE_ON_FLASH=${ARGS[$((++i))]};;
        -e1|-e) SDCARD_ERASE_ON_FLASH=1;;
        -e0)    SDCARD_ERASE_ON_FLASH=0;;

        --sdcard-erase-on-flash-src)
            SDCARD_ERASE_ON_FLASH_SRC=${ARGS[$((++i))]}
            [[ -e "${SDCARD_ERASE_ON_FLASH_SRC}" ]] || quit 1 "No such file: ${SDCARD_ERASE_ON_FLASH_SRC}"
            ;;

        --sdcard-verify-integrity) SDCARD_VERIFY_INTEGRITY=${ARGS[$((++i))]};;

        --sdcard-verify-real-size) SDCARD_VERIFY_REAL_SIZE=${ARGS[$((++i))]};;

        --sdcard-check-rootfs-for-errors) SDCARD_CHECK_ROOTFS_FOR_ERRORS=${ARGS[$((++i))]};;

        --dd-bs)
            DD_BS=${ARGS[$((++i))]}
            [[ "${DD_BS}" =~ ^[1-9][0-9]*(c|w|b|kB|K|MB|M|xM|GB|G|T)?$ ]] || quit 1 "Invalid dd block size: ${DD_BS}"
            # dd also support suffixes P|E|Z|Y, but they are too big for our purposes.
            ;;
        --dd-conv)
            DD_CONV=${ARGS[$((++i))]}
            if [[ -n "${DD_CONV}" ]]; then
                # Remove initial and trailing comma if any
                if [[ "${DD_CONV::1}" == ',' ]]; then
                    DD_CONV="${DD_CONV:1}"
                fi
                if [[ "${DD_CONV: -1}" == ',' ]]; then
                    DD_CONV="${DD_CONV:: -1}"
                fi

                IFS=, read -ra tmp <<<"${DD_CONV}"
                for o in "${tmp[@]}"; do
                    case "${o}" in
                        sparse|sync|noerror) ;;  # Ignore this list, others are not suitable for our purposes.
                        fdatasync|fsync)
                            DD_CONV_FSYNC=$o
                            DD_CONV=${DD_CONV//,$o,}
                            DD_CONV=${DD_CONV//,$o}
                            DD_CONV=${DD_CONV//$o,}
                            DD_CONV=${DD_CONV//$o}
                            ;;
                        *) quit 1 "Unsupported dd conv option: ${o}"
                    esac
                done
            fi
            ;;
        --dd-oflag)
            DD_OFLAG=${ARGS[$((++i))]}
            case "${DD_OFLAG}" in
                ''|direct|nonblock|direct,nonblock|nonblock,direct) ;;  # Ignore this list
                *) quit 1 "Unsupported dd oflag options: ${DD_OFLAG}"
            esac
            ;;
        --dd-status)
            DD_STATUS=${ARGS[$((++i))]}
            case "${DD_STATUS}" in
                ''|none|noxfer|progress) ;;  # Ignore this list
                *) quit 1 "Unsupported dd status option: ${DD_STATUS}"
            esac
            ;;

        --early-boot-ssh) EARLY_BOOT_SSH=${ARGS[$((++i))]};;

        --shrink-rootfs) SHRINK_ROOTFS=${ARGS[$((++i))]};;

        --expand-rootfs) EXPAND_ROOTFS=${ARGS[$((++i))]};;

        --regenerate-ssh-server-keys) REGENERATE_SSH_SERVER_KEYS=${ARGS[$((++i))]};;

        --tar-pack) TAR_PACK=${ARGS[$((++i))]};;
        -t1|-i) TAR_PACK=1;;
        -t0)    TAR_PACK=0;;

        --xz-opt|--tar-xz-opt)
            # Overwrite default value with XZ_LEVEL inside
            XZ_OPT=${ARGS[$((++i))]}
            ;;

        --apt-extra-pkgs) APT_EXTRA_PKGS=${ARGS[$((++i))]};;

        --apt-dist-upgrade) APT_DIST_UPGRADE=${ARGS[$((++i))]};;
        --apt-upgrade) APT_UPGRADE=${ARGS[$((++i))]};;
        --apt-autoremove) APT_AUTOREMOVE=${ARGS[$((++i))]};;

        --cert-subj)
            CERT_SUBJ=${ARGS[$((++i))]}
            # [[ "${CERT_SUBJ}" =~ ^(/C=[A-Z][A-Z])?(/ST=[a-zA-Z0-9-]+)?(/L=[a-zA-Z0-9-]+)?(/O=[a-zA-Z0-9-]+)?(/OU=[a-zA-Z0-9-]+)?(/CN=.+)?(/emailAddress=[a-zA-Z0-9-._]+@[a-zA-Z0-9-._]+)?/$ ]] || quit 1 "Invalid certificate subject: ${CERT_SUBJ}"
            ;;

        --cert-dh-sz)
            CERT_DH_SZ=${ARGS[$((++i))]}
            case "${CERT_DH_SZ}" in
                256|512|1024|2048|4096|8192|16384) ;;
                *) quit 1 "Invalid Diffie-Hellman cert size: ${CERT_DH_SZ}";;
            esac
            ;;
        --cert-valid-days)
            CERT_VALID_DAYS=${ARGS[$((++i))]}
            [[ "${CERT_VALID_DAYS}" =~ ^[0-9]+$ ]] || quit 1 "Invalid --cert-valid-days value: ${CERT_VALID_DAYS}"
            ;;

        --pi-username)
            PI_USERNAME=${ARGS[$((++i))]}
            if ! [[ "${PI_USERNAME}" =~ ^[a-z_][a-z0-9_]{0,30}$ ]]; then
                quit 1 "Invalid username: ${PI_USERNAME}"
            fi
            for tmp in root daemon bin sys sync games man lp mail news uucp proxy www-data backup list irc gnats nobody systemd-timesync systemd-network systemd-resolve systemd-bus-proxy _apt apt messagebus statd ssh sshd avahi dnsmasq liquidsoap icecast2 config Debian-exim usbmux; do
                [[ "${tmp}" == "${PI_USERNAME}" ]] && quit 1 "Username is in exception list (choose another one): ${PI_USERNAME}"
            done
            ;;

        --flash) FLASH=${ARGS[$((++i))]};;

        --post-flashing) POST_FLASHING=${ARGS[$((++i))]};;
        --cert-generate) CERT_GENERATE=${ARGS[$((++i))]};;

        --interactive) INTERACTIVE=${ARGS[$((++i))]};;
        -i1|-i) INTERACTIVE=1;;
        -i0)    INTERACTIVE=0;;

        --sd-overclock)
            SD_OVERCLOCK=${ARGS[$((++i))]}
            case "${SD_OVERCLOCK}" in
                0|25|40|50|80|100) ;;  # Valid values (integer divisors of the core clock 400)
                *) quit 1 "Invalid SD_OVERCLOCK value: ${SD_OVERCLOCK}"
            esac
            ;;

        --automounting-enabled) AUTOMOUNTING_ENABLED=${ARGS[$((++i))]};;

        # --dry-run) DRY_RUN=${ARGS[$((++i))]};;

        *) quit 1 "Invalid option: ${ARGS[$i]}"
    esac
done

## Arguments post processing
# # Force non-interactive shell if cannot be interactive
# case "$-" in
#     *i*) ;;             # interactive
#     *) INTERACTIVE=0;;  # non-interactive
# esac

# Convert boolean vars to 0 or 1
for o in APT_AUTOREMOVE APT_DIST_UPGRADE APT_UPGRADE AUTOMOUNTING_ENABLED CERT_GENERATE EARLY_BOOT_SSH EXPAND_ROOTFS FLASH INTERACTIVE KEEP_SRC_IMAGE POST_FLASHING REGENERATE_SSH_SERVER_KEYS SDCARD_ERASE_ON_FLASH SDCARD_VERIFY_INTEGRITY SDCARD_CHECK_ROOTFS_FOR_ERRORS SDCARD_VERIFY_REAL_SIZE SHRINK_ROOTFS TAR_PACK
do
    case "${!o,,}" in
        # 'on' and 'off' removed from choices to avoid mistype no/on
        1|y|yes|true) printf -v "${o}" '%s' 1;;
        0|n|no|false) printf -v "${o}" '%s' 0;;
        '') ;;  # Keep empty values. Note: `((''))` is False (has return code 1)
        *)  O=${o,,}
            quit 1 "Invalid value for boolean option --${O//_/-}: ${!o}"
    esac
done

# Get rid of relative paths, use absolute paths
for o in IMG MOUNT_DIR ROOTFS_CHANGES_DIR SDCARD SDCARD_ERASE_ON_FLASH_SRC TMP_DIR WORK_DIR
do
    [[ -z "${!o}" ]] && continue  # Ignore empty variables
    tmp=$(exec -c realpath "${!o}") || quit 1 "Failed to get real path: ${!o}"
    [[ "${tmp}" == '/' ]] && quit 1 "Option cannot be root directory /: ${o}"
    printf -v "${o}" '%s' "${tmp}"
done

# Start work in WORK_DIR
cd "${WORK_DIR}" || quit 1 "Failed to change directory to WORK_DIR: ${WORK_DIR}"

[[ -z "${TMP_DIR}" ]] && TMP_DIR="${TMP_DIR_DEFAULT_DIRNAME}/${TMP_DIR_DEFAULT_BASENAME}"
if ! [[ -d "${TMP_DIR}" ]]; then
    log "Creating temporary directory: ${TMP_DIR}"
    mkdir -vp "${TMP_DIR}" 2>/dev/null || sudo mkdir -vp "${TMP_DIR}" || quit 1 'Failed to create temporary directory'
fi

[[ -z "${MOUNT_DIR}" ]] && MOUNT_DIR=${TMP_DIR}

if ((INTERACTIVE)); then
    [[ -z "${DD_STATUS}" ]] && DD_STATUS='progress'
    [[ -z "${XZ_OPT}" ]] && XZ_OPT="-${XZ_LEVEL}v"
else  # non-interactive
    [[ -z "${DD_STATUS}" ]] && DD_STATUS='none'
    [[ -z "${XZ_OPT}" ]] && XZ_OPT="-${XZ_LEVEL}"
    export DEBIAN_FRONTEND='noninteractive'
fi
export XZ_OPT

# status=progress introduces in dd version 8.24, do not use it with older verions
# DD_VERSION=$(LC_ALL=C dd --version | grep -m1 -o '[0-9]\+\.[0-9]\+')
read -r _ _ DD_VERSION <<<"$(exec -c dd --version)"
printf -v DD_VERSION '%d%03d' "${DD_VERSION%%.*}" "${DD_VERSION#*.}"
if ((DD_VERSION < 8024)) && [[ "${DD_STATUS}" == 'progress' ]]; then
    DD_STATUS=''
fi

# Append option name prefix to non empty DD_* vars
[[ -n "${DD_STATUS}" ]] && DD_STATUS="status=${DD_STATUS}"
[[ -n "${DD_BS}" ]] && DD_BS="bs=${DD_BS}"
[[ -n "${DD_OFLAG}" ]] && DD_OFLAG="oflag=${DD_OFLAG}"
[[ -n "${DD_CONV}" ]] && DD_CONV="conv=${DD_CONV_FSYNC},${DD_CONV}" || DD_CONV="conv=${DD_CONV_FSYNC}"

# See also per-ACTION processing
## END Arguments post processing
### END Parse arguments


### Main case
case "${ACTION}" in
    create)
        # Ask for PI_IMAGE_VERSION if not set or invalid
        [[ -z "${PI_IMAGE_VERSION}" && "${INTERACTIVE}" -eq 0 ]] && quit 240 'Unable to ask for disk image version version because of non-interactive mode'
        for ((i=0;i<3;i++)); do
            [[ "${PI_IMAGE_VERSION}" =~ ^[0-9a-zA-Z._]+$ ]] && break
            ((i)) && echo 'Only alphanumeric characters with dot and underscore supported! Just number or "dev" are suitable choises.' >&2
            read -r -p "Enter disk image version (attempt $((i+1))/3): " PI_IMAGE_VERSION
        done
        ((i<3)) || quit 1 'No valid disk image version specified'

        # Sort out RASPBIAN_NAME
        if [[ -n "${RASPBIAN_NAME}" ]]; then
            :  # Do nothing - was set as command line option
        elif [[ -n "${SOURCE_IMAGE_URL_FILENAME}" ]]; then
            # SOURCE_IMAGE_URL was set as command line option
            # SOURCE_IMAGE_URL_FILENAME set based on the url filename
            RASPBIAN_NAME=${SOURCE_IMAGE_URL_FILENAME}
            if [[ -z "${RASPBIAN_NAME/*\/*/}" ]]; then  # / in the name or empty
                RASPBIAN_NAME='raspbian'  # URL/filename is unavailable, fallback to default
                log "Failed to extract Raspbian image filename from url, fallback to: ${RASPBIAN_NAME}"
            fi
        else
            # Get RASPBIAN_NAME from default SOURCE_IMAGE_URL
            # shellcheck disable=2086
            wget_header=$(exec -c wget -qS --spider ${WGET_TIMEOUTS} "${SOURCE_IMAGE_URL}" 2>&1)
            # If 'Content-Disposition: * filename=' exists
            if [[ -n "${wget_header}" && -z "${wget_header##*Content-Disposition:* filename=*}" ]]; then
                wget_filename=${wget_header##*Content-Disposition:* filename=}  # tmp
                wget_filename=${wget_filename%%$'\n'*}  # E.g.: 2017-09-07-raspbian-stretch-lite.zip
            # If failed to extract using filename= use last Location: value
            elif [[ -n "${wget_header}" && -z "${wget_header##*Location:*}" ]]; then
                wget_filename=${wget_header##*Location:}  # tmp
                wget_filename=${wget_filename%%$'\n'*}  # tmp
                wget_filename=${wget_filename##*/}
            fi
            if [[ -z "${wget_filename}" ]]; then
                RASPBIAN_NAME='raspbian'  # URL/filename is unavailable, fallback to default
                log "Failed to extract Raspbian image filename from url, fallback to: ${RASPBIAN_NAME}"
            else
                RASPBIAN_NAME=${wget_filename%\.*}  # With extension removed (probably .zip)
                log "Autodetected Raspbian image name: ${RASPBIAN_NAME}"
            fi
            unset wget_header wget_rcode wget_filename
        fi
        [[ "${RASPBIAN_NAME: -4}" != '.img' ]] && RASPBIAN_NAME+='.img'  # Add 'img' extension if absent
        unset SOURCE_IMAGE_URL_FILENAME

        # Generate RASPBIAN_IMG variable
        RASPBIAN_IMG="${WORK_DIR}/${RASPBIAN_NAME}"  # Will be downloaded if empty or does not exists

        create_image
        rval=$?
        ;;

    flash)
        # Ask for IMG if not set or invalid
        [[ -z "${IMG}" && "${INTERACTIVE}" -eq 0 ]] && quit 240 'Unable to ask for image location because of non-interactive mode'
        for ((i=0;i<3;i++)); do
            [[ -f "${IMG}" || -b "${IMG}" ]] && IMG=$(exec -c realpath "${IMG}") && break
            ((i)) && echo 'No such file or block device!' >&2
            # shellcheck disable=2162
            read -p "Enter path to the disk image (attempt $((i+1))/3): " IMG
        done
        ((i<3)) || quit 1 'No valid disk image found'

        # Ask for SDCARD if not set or invalid
        [[ -z "${SDCARD}" && "${INTERACTIVE}" -eq 0 ]] && quit 240 'Unable to ask for SD card device because of non-interactive mode'
        for ((i=0;i<3;i++)); do
            [[ -b "${SDCARD}" || -c "${SDCARD}" ]] && SDCARD=$(exec -c realpath "${SDCARD}") && break
            ((i)) && echo 'Not a block or character special device!' >&2
            # shellcheck disable=2162
            read -p "Enter path to SD card (attempt $((i+1))/3): " SDCARD
        done
        ((i<3)) || quit 1 'No valid SD card specified'

        # Some validations
        if [[ -z "$(exec -c sudo sfdisk --color=never -q -l -o device -- "${IMG}")" ]]; then
            log "WARNING: The image may be broken: no partitions found"
        fi

        flash_image "${IMG}"
        rval=$?
        ((rval==0)) && log "OK: Now you can physically detach SD card ${SDCARD}"
        ;;

    mount)
        [[ -f "${IMG}" || -b "${IMG}" ]] || quit 1 'Disk image not found'
        mount_img "${IMG}"
        rval=$?
        ;;

    umount|unmount)
        [[ -f "${IMG}" || -b "${IMG}" ]] || quit 1 'Disk image not found'
        umount_img "${IMG}" --rmdir
        rval=$?
        ;;
esac

quit "${rval:-255}"
